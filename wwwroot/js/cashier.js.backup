// ===============================================
// JavaScript for Cashier Page - Clean Version
// ===============================================

// ===============================================
// Simplified Cashier System - Global Variables
// ===============================================
let cart = [];
let isReturnMode = false; // Simple toggle instead of multiple modes
let currentSearchMode = 'qr';
let searchTimeout = null;
let selectedProductInfo = null; // For color/size selection


// Make cart accessible globally
window.cart = cart;

// Clean up old cart tracker entries to prevent memory leaks
function cleanupCartTracker() {
    if (!window.cartAddTracker) return;
    
    const now = Date.now();
    const maxAge = 30000; // 30 seconds
    
    Object.keys(window.cartAddTracker).forEach(key => {
        if (now - window.cartAddTracker[key] > maxAge) {
            delete window.cartAddTracker[key];
        }
    });
}

// Clean up old QR search tracker entries
function cleanupQRSearchTracker() {
    if (!window.qrSearchTracker) return;
    
    const now = Date.now();
    const maxAge = 30000; // 30 seconds
    
    Object.keys(window.qrSearchTracker).forEach(key => {
        if (now - window.qrSearchTracker[key] > maxAge) {
            delete window.qrSearchTracker[key];
        }
    });
}

// Run cleanup every 30 seconds
setInterval(cleanupCartTracker, 30000);
setInterval(cleanupQRSearchTracker, 30000);

// Ø¥Ø²Ø§Ù„Ø© Ø±Ø³Ø§Ø¦Ù„ console ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬


// Ù…Ù†Ø¹ inspect Ù„Ù„ØµÙØ­Ø© Ø¹Ù†Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø§Ø³Ø­ Ø§Ù„Ø¶ÙˆØ¦ÙŠ
document.addEventListener('keydown', function(e) {
    // Ù…Ù†Ø¹ F12 Ùˆ Ctrl+Shift+I Ùˆ Ctrl+Shift+C
    if (e.key === 'F12' || 
        (e.ctrlKey && e.shiftKey && e.key === 'I') ||
        (e.ctrlKey && e.shiftKey && e.key === 'C') ||
        (e.ctrlKey && e.key === 'u')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
});

// Ù…Ù†Ø¹ right-click ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø§Ø³Ø­ Ø§Ù„Ø¶ÙˆØ¦ÙŠ
document.addEventListener('contextmenu', function(e) {
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput && e.target.closest('.qr-input-group')) {
        e.preventDefault();
        return false;
    }
});

// Debug function to check cart status
window.checkCart = function() {
    return cart;
};

// Debug function to test color/size modal
// Make handleColorSizeConfirm globally available
window.handleColorSizeConfirm = handleColorSizeConfirm;

// Test function to verify button is working
// Debug function to check return tracking records
window.checkReturnTrackings = function(invoiceNumber = '') {
   
    
    const url = invoiceNumber 
        ? `/Cashier/GetReturnTrackings?invoiceNumber=${encodeURIComponent(invoiceNumber)}`
        : '/Cashier/GetReturnTrackings';
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
               
                
                if (data.trackings.length > 0) {
                  
                } else {
                 
                }
            } else {
               
            }
        })
        .catch(error => {
           
        });
};

// ===============================================
// Basic Functions
// ===============================================

// Get current mode (simplified)
function getCurrentMode() {
    return isReturnMode ? 'return' : 'sale';
}

// Note: Automatic number generation has been removed as requested

// Note: Fallback number generation has been removed as requested



// Check if invoice number already exists
async function checkInvoiceNumberDuplicate(invoiceNumber) {
    if (!invoiceNumber || invoiceNumber.trim() === '') {
        clearInvoiceNumberStatus();
        return null;
    }
    
    try {
        const response = await fetch(`/Cashier/CheckInvoiceNumberDuplicate?invoiceNumber=${encodeURIComponent(invoiceNumber.trim())}`);
        const result = await response.json();
        
        const statusDiv = document.getElementById('invoiceNumberStatus');
        const input = document.getElementById('invoiceNumber');
        
        if (result.exists) {
            statusDiv.innerHTML = '<small class="text-danger">âŒ Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ ÙØ§ØªÙˆØ±Ø© Ø£Ø®Ø±Ù‰</small>';
            input.classList.add('is-invalid');
            input.classList.remove('is-valid');
        } else {
            statusDiv.innerHTML = '<small class="text-success">âœ… Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ù…ØªØ§Ø­ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</small>';
            input.classList.add('is-valid');
            input.classList.remove('is-invalid');
        }
        
        return result;
    } catch (error) {
        console.error('Error checking invoice number:', error);
        const statusDiv = document.getElementById('invoiceNumberStatus');
        statusDiv.innerHTML = '<small class="text-warning">âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù‚Ù…</small>';
        return { exists: false, message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚' };
    }
}

// Check if order number already exists
async function checkOrderNumberDuplicate(orderNumber) {
    if (!orderNumber || orderNumber.trim() === '') {
        clearOrderNumberStatus();
        return null;
    }
    
    try {
        const response = await fetch(`/Cashier/CheckOrderNumberDuplicate?orderNumber=${encodeURIComponent(orderNumber.trim())}`);
        const result = await response.json();
        
        const statusDiv = document.getElementById('orderNumberStatus');
        const input = document.getElementById('orderNumber');
        
        if (result.exists) {
            statusDiv.innerHTML = '<small class="text-danger">âŒ Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø£Ù…Ø± Ø¢Ø®Ø±</small>';
            input.classList.add('is-invalid');
            input.classList.remove('is-valid');
        } else {
            statusDiv.innerHTML = '<small class="text-success">âœ… Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ù…ØªØ§Ø­ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…</small>';
            input.classList.add('is-valid');
            input.classList.remove('is-invalid');
        }
        
        return result;
    } catch (error) {
        console.error('Error checking order number:', error);
        const statusDiv = document.getElementById('orderNumberStatus');
        statusDiv.innerHTML = '<small class="text-warning">âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù‚Ù…</small>';
        return { exists: false, message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚' };
    }
}

// Clear invoice number status
function clearInvoiceNumberStatus() {
    const statusDiv = document.getElementById('invoiceNumberStatus');
    const input = document.getElementById('invoiceNumber');
    if (statusDiv) statusDiv.innerHTML = '';
    if (input) {
        input.classList.remove('is-valid', 'is-invalid');
    }
}

// Clear order number status
function clearOrderNumberStatus() {
    const statusDiv = document.getElementById('orderNumberStatus');
    const input = document.getElementById('orderNumber');
    if (statusDiv) statusDiv.innerHTML = '';
    if (input) {
        input.classList.remove('is-valid', 'is-invalid');
    }
}

// Toggle between sale and return mode - REMOVED
// This function has been removed as the mode selection section was removed from the UI


// Enhanced product search with multiple modes and autocomplete
let searchCache = new Map();



// Enhanced product search function
async function searchProducts(term, options = {}) {
    const {
        category = '',
        color = '',
        size = '',
        minPrice = null,
        maxPrice = null,
        includeOutOfStock = true,
        searchMode = 'standard',
        limit = 20,
        useCache = true
    } = options;

    // Create cache key
    const cacheKey = JSON.stringify({ term, category, color, size, minPrice, maxPrice, includeOutOfStock, searchMode, limit });
    
    // Check cache first
    if (useCache && searchCache.has(cacheKey)) {
       
        return searchCache.get(cacheKey);
    }

    try {
        // Build query parameters
        const params = new URLSearchParams();
        if (term) params.append('term', term);
        if (category) params.append('category', category);
        if (color) params.append('color', color);
        if (size) params.append('size', size);
        if (minPrice !== null) params.append('minPrice', minPrice);
        if (maxPrice !== null) params.append('maxPrice', maxPrice);
        params.append('includeOutOfStock', includeOutOfStock);
        params.append('searchMode', searchMode);
        params.append('limit', limit);

     
        
        const response = await fetch(`/Cashier/SearchProducts?${params.toString()}`);
        const result = await response.json();

        // Cache successful results
        if (useCache && result.success) {
            searchCache.set(cacheKey, result);
            
            // Clear old cache entries (keep only last 20)
            if (searchCache.size > 20) {
                const firstKey = searchCache.keys().next().value;
                searchCache.delete(firstKey);
            }
        }

        return result;
    } catch (error) {
       
        return {
            success: false,
            message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«',
            products: []
        };
    }
}

// Product autocomplete/suggestions
async function getProductSuggestions(term, limit = 5) {
    if (!term || term.length < 2) {
        return { success: false, suggestions: [] };
    }

    try {
        const response = await fetch(`/Cashier/GetProductSuggestions?term=${encodeURIComponent(term)}&limit=${limit}`);
        const result = await response.json();
        return result;
    } catch (error) {
      
        return { success: false, suggestions: [] };
    }
}

// Live search with debouncing
function initializeLiveSearch(inputElement, resultsContainer, onSelectCallback) {
    if (!inputElement || !resultsContainer) return;

    let debounceTimer = null;
    let currentTerm = '';

    inputElement.addEventListener('input', function() {
        const term = this.value.trim();
        
        // Clear previous timer
        if (debounceTimer) {
            clearTimeout(debounceTimer);
        }

        // Clear results if input is too short
        if (term.length < 2) {
            resultsContainer.innerHTML = '';
            resultsContainer.style.display = 'none';
            return;
        }

        // Skip if same term
        if (term === currentTerm) return;
        currentTerm = term;

        // Show loading
        resultsContainer.innerHTML = '<div class="search-loading">ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...</div>';
        resultsContainer.style.display = 'block';

        // Debounce search
        debounceTimer = setTimeout(async () => {
            try {
                const result = await searchProducts(term, { limit: 10 });
                
                if (result.success && result.products.length > 0) {
                    displaySearchResults(result.products, resultsContainer, onSelectCallback);
                } else {
                    resultsContainer.innerHTML = '<div class="search-no-results">âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬</div>';
                }
            } catch (error) {
                console.error('âŒ Live search error:', error);
                resultsContainer.innerHTML = '<div class="search-error">âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«</div>';
            }
        }, 300); // 300ms debounce
    });

    // Hide results when clicking outside
    document.addEventListener('click', function(event) {
        if (!inputElement.contains(event.target) && !resultsContainer.contains(event.target)) {
            resultsContainer.style.display = 'none';
        }
    });
}

// Display search results in dropdown
function displaySearchResults(products, container, onSelectCallback) {
    if (!products || !container) return;

    let html = '<div class="search-results-dropdown">';
    
    products.forEach(product => {
        const stockClass = product.isAvailable ? 'available' : 'out-of-stock';
        const stockIcon = product.isAvailable ? 'âœ…' : 'âŒ';
        
        html += `
            <div class="search-result-item ${stockClass}" data-product-id="${product.id}" onclick="selectSearchResult(${product.id}, '${escapeHtml(product.name)}', ${product.price}, '${product.color || ''}', '${product.size || ''}')">
                <div class="product-info">
                    <div class="product-name">${escapeHtml(product.name)}</div>
                    <div class="product-details">
                        <span class="price">ğŸ’° ${product.price.toFixed(2)} Ø¬Ù†ÙŠÙ‡</span>
                        <span class="stock">${stockIcon} ${product.stockStatus}</span>
                        ${product.category ? `<span class="category">ğŸ“ ${escapeHtml(product.category)}</span>` : ''}
                    </div>
                </div>
                <div class="product-actions">
                    <button type="button" class="btn-add-search" onclick="event.stopPropagation(); addProductToCart(${product.id}, '${escapeHtml(product.name)}', ${product.price}, '${product.color || ''}', '${product.size || ''}')">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
    container.style.display = 'block';
    
    // Add click handlers if callback provided
    if (onSelectCallback) {
        container.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', function() {
                const productId = this.dataset.productId;
                const productName = this.querySelector('.product-name').textContent;
                const productPrice = parseFloat(this.querySelector('.price').textContent.match(/[\d.]+/)[0]);
                
                onSelectCallback(productId, productName, productPrice);
                container.style.display = 'none';
            });
        });
    }
}

// Search result selection handler
function selectSearchResult(productId, productName, productPrice, productColor = null, productSize = null) {
    
    
    // Add to cart automatically with default color and size
    addProductToCart(productId, productName, productPrice, productColor, productSize);
    
    // Clear search results
    const searchContainers = document.querySelectorAll('.search-results-dropdown');
    searchContainers.forEach(container => {
        container.style.display = 'none';
    });
    
    // Show confirmation message
    showMessage(`âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© ${productName} Ø¥Ù„Ù‰ Ø§Ù„Ø³Ù„Ø©`, 'success');
}

// Add product to cart (simplified with positive/negative quantities)
async function addProductToCart(productId, productName, productPrice, productColor = null, productSize = null) {
    // Validate input parameters
    if (!productId || !productName || !productPrice) {
        console.error('âŒ Invalid parameters for addProductToCart:', { productId, productName, productPrice });
        showMessage('âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'error');
        return;
    }
    
    // Proceed with duplicate-prevention logic below; do not short-circuit directly to addProductToCartWithColorSize
    
    // Enhanced duplicate prevention at cart level
    const now = Date.now();
    const cartKey = `${productId}_${productName}`;
    
    // Initialize cart tracker
    if (!window.cartAddTracker) {
        window.cartAddTracker = {};
    }
    
    // Prevent adding the same product within 1 second
    if (window.cartAddTracker[cartKey] && (now - window.cartAddTracker[cartKey]) < 1000) {
       
        return;
    }
    
    // Update tracker
    window.cartAddTracker[cartKey] = now;
    
    try {
       
        
        // Determine quantity based on current mode
        const baseQuantity = 1;
        const quantity = isReturnMode ? -baseQuantity : baseQuantity;
        const total = quantity * productPrice;
        
       
        
        // Validate productId
        if (!productId || productId === 0) {
            console.error('âŒ Invalid productId:', productId);
            alert('âŒ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­');
            return;
        }
        
        // Create cart item
        const cartItem = {
            id: Date.now(),
            productId: parseInt(productId), // Ensure it's a number
            name: productName,
            price: parseFloat(productPrice), // Ensure it's a number
            quantity: quantity, // Positive for sale, negative for return
            total: total,       // Will be negative for returns
            discount: 0         // Initialize discount to 0
        };
        
        // Ensure total is correctly calculated
        cartItem.total = quantity * productPrice;
        
        console.log('ğŸ“¦ Created cart item:', cartItem);
        
        // Check for duplicate returns prevention
        if (isReturnMode) {
            const existingReturnItem = cart.find(item => 
                (item.productId == cartItem.productId || item.name === cartItem.name) && item.quantity < 0
            );
            
            if (existingReturnItem) {
                
                existingReturnItem.quantity -= 1; // Make it more negative
                
                // Recalculate total with discount
                const itemSubTotal = Math.abs(existingReturnItem.price * existingReturnItem.quantity);
                const discountAmount = existingReturnItem.discount || 0; // Direct amount
                existingReturnItem.total = Math.round(-(itemSubTotal - discountAmount) * 100) / 100;
                
              
            } else {
        // Add to cart
        cart.push(cartItem);
            }
        } else {
            // Add to cart normally for sales
            cart.push(cartItem);
        }
        
        window.cart = cart;
        
        // Update display
        updateCartDisplay();
        updateCartSummary();
        
        // Update process button state safely
        if (typeof updateProcessButtonState === 'function') {
        updateProcessButtonState();
        } else {
            console.warn('âš ï¸ updateProcessButtonState function not available');
        }
        
        const modeText = isReturnMode ? 'Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹' : 'Ù„Ù„Ø¨ÙŠØ¹';
       
        
        // Show success notification
        showMessage(`âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© ${productName} ${modeText}`, 'success');
        
        // Note: Automatic number generation has been removed as requested
        
    } catch (error) {
       
        showMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù„Ø³Ù„Ø©', 'error');
    }
}

// Enhanced QR/Scanner input processing
function processScannerInput(scannedData) {

    if (!scannedData || typeof scannedData !== 'string') {
        updateQRStatus('error', 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
        showMessage('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø§Ø³Ø­ ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'warning');
        return;
    }
    
    // Clean and validate the scanned data
    let cleanData = scannedData.trim();
    
    // Remove special characters that might cause issues (keep dots for decimal numbers)
    cleanData = cleanData.replace(/[^\w\s\-_\.]/g, '');
    
    // Remove extra spaces
    cleanData = cleanData.replace(/\s+/g, ' ').trim();
    
    if (!cleanData || cleanData.length < 1) {
        updateQRStatus('error', 'Ø±Ù…Ø² QR ÙØ§Ø±Øº');
        showMessage('Ø±Ø¬Ø§Ø¡Ù‹ Ø§Ù…Ø³Ø­ QR Code ØµØ­ÙŠØ­', 'warning');
        
        // Reset for next scan
        setTimeout(() => {
            updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
            refocusQRInput();
        }, 1500);
        return;
    }
    
    // Use the optimized search function
    simpleQRSearch(cleanData);
}



// Refocus QR input for continuous scanning (only when appropriate)
function refocusQRInput() {
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput && currentSearchMode === 'qr' && !isUserInteractingWithOtherElements()) {
        // Clear input first
        qrInput.value = '';
        
        // Refocus with slight delay to ensure stability, but only if user isn't busy
        setTimeout(() => {
            if (!isUserInteractingWithOtherElements()) {
                qrInput.focus();
            }
        }, 100);
    }
}

// Play success sound for scanner feedback
function playSuccessSound() {
    try {
        // Create audio context for beep sound
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800; // High pitch beep
        gainNode.gain.value = 0.1; // Low volume
        
        oscillator.start();
        setTimeout(() => {
            oscillator.stop();
        }, 150); // Short beep
    } catch (error) {
        // Ignore audio errors - not critical
        console.log('Audio feedback not available');
    }
}


// Update QR status display
function updateQRStatus(status, message) {
    
    const qrStatus = document.getElementById('qrStatus');
    if (qrStatus) {
        // Update the text inside the status-text span
        const statusText = qrStatus.querySelector('.status-text');
        if (statusText) {
            statusText.textContent = message;
        } else {
            // Fallback if structure is different
            qrStatus.textContent = message;
        }
        
        // Remove existing status classes
        qrStatus.classList.remove('status-ready', 'status-loading', 'status-success', 'status-error');
        
        // Add appropriate status class
        switch(status) {
            case 'ready':
                qrStatus.classList.add('status-ready');
                qrStatus.style.color = '#007bff';
                break;
            case 'loading':
                qrStatus.classList.add('status-loading');
                qrStatus.style.color = '#ffc107';
                break;
            case 'success':
                qrStatus.classList.add('status-success');
                qrStatus.style.color = '#28a745';
                break;
            case 'error':
                qrStatus.classList.add('status-error');
                qrStatus.style.color = '#dc3545';
                break;
            default:
                qrStatus.style.color = '#6c757d';
        }
    }
}

// Clear QR input field
function clearQRInput() {
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput) {
        qrInput.value = '';
        qrInput.focus();
        updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
       
    }
}


// Check if user is interacting with other important elements
function isUserInteractingWithOtherElements() {
    const activeElement = document.activeElement;
    if (!activeElement) return false;
    
    // Don't refocus if user is typing in other important inputs
    const importantInputs = ['customerSelect', 'customerName', 'customerPhone', 'amountPaid'];
    const isImportantInput = importantInputs.some(id => activeElement.id === id);
    
    // Don't refocus if user is interacting with buttons or modals
    const isButton = activeElement.tagName === 'BUTTON';
    const isInModal = activeElement.closest('.modal');
    
    return isImportantInput || isButton || isInModal;
}

// Event handlers for QR input - Optimized version
function handleQRKeydown(e) {
    // Prevent inspect and debugging shortcuts
    if (e.key === 'F12' || e.key === 'F11' || e.key === 'F5' || 
        (e.ctrlKey && e.shiftKey && e.key === 'I') ||
        (e.ctrlKey && e.shiftKey && e.key === 'C') ||
        (e.ctrlKey && e.key === 'u')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
    
    if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        
        const qrCode = e.target.value.trim();
        
        if (qrCode) {
            // Process the QR code
            simpleQRSearch(qrCode);
            e.target.value = ''; // Clear immediately for next scan
        } else {
            updateQRStatus('error', 'Ø§ÙƒØªØ¨ Ø±Ù…Ø² QR');
            setTimeout(() => {
                updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
            }, 2000);
        }
        return false;
    }
}

function handleQRInput(e) {
    // This fires on every character input
    const value = e.target.value;
    if (value.length > 0) {
        updateQRStatus('loading', `ÙƒØªØ§Ø¨Ø©... (${value.length} Ø­Ø±Ù)`);
    } else {
        updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
    }
}

function handleQRPaste(e) {
    e.preventDefault();
    const pastedData = (e.clipboardData || window.clipboardData).getData('text');
    if (pastedData && pastedData.trim()) {
        simpleQRSearch(pastedData.trim());
        e.target.value = '';
    }
}

// SIMPLE QR SEARCH - Optimized and clean with enhanced validation
async function simpleQRSearch(qrCode) {
    if (!qrCode || qrCode.trim() === '') {
        updateQRStatus('error', 'Ø±Ù…Ø² QR ÙØ§Ø±Øº');
        return;
    }
    
    // Enhanced validation
    const cleanQRCode = qrCode.trim();
    if (cleanQRCode.length < 1) {
        updateQRStatus('error', 'Ø±Ù…Ø² QR ÙØ§Ø±Øº');
        showMessage('Ø±Ø¬Ø§Ø¡Ù‹ Ø§Ù…Ø³Ø­ QR Code ØµØ­ÙŠØ­', 'warning');
        return;
    }
    
    // Prevent multiple searches for the same QR code within 3 seconds
    const now = Date.now();
    const searchKey = `qr_search_${cleanQRCode}`;
    
    if (!window.qrSearchTracker) {
        window.qrSearchTracker = {};
    }
    
    if (window.qrSearchTracker[searchKey] && (now - window.qrSearchTracker[searchKey]) < 3000) {
        console.log(`âš ï¸ QR: Preventing duplicate search for ${cleanQRCode} (last search ${now - window.qrSearchTracker[searchKey]}ms ago)`);
        showMessage(`ØªÙ… Ù…Ù†Ø¹ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ÙƒØ±Ø± Ù„Ù†ÙØ³ Ø§Ù„Ø±Ù…Ø²`, 'warning');
        return;
    }
    
    // Lock to prevent concurrent processing of the same QR end-to-end
    if (!window.qrProcessing) window.qrProcessing = {};
    if (window.qrProcessing[searchKey]) {
        return;
    }
    window.qrProcessing[searchKey] = true;
    window.qrSearchTracker[searchKey] = now;
    
    updateQRStatus('loading', 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...');
    
    try {
        // Direct API call - simple and straightforward
        const response = await fetch(`/Cashier/SearchProducts?term=${encodeURIComponent(cleanQRCode)}&includeOutOfStock=true`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success && result.products && result.products.length > 0) {
            // Enhanced validation: Check if we have exactly one product or multiple
            if (result.products.length > 1) {
                console.warn(`âš ï¸ Multiple products found for QR: ${cleanQRCode}, using first one`);
                showMessage(`ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${result.products.length} Ù…Ù†ØªØ¬Ø§ØªØŒ Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ÙˆÙ„`, 'warning');
            }
            
            const product = result.products[0];
            
            // Enhanced validation before adding to cart
            if (!product.id || !product.name || !product.price) {
                console.error('âŒ Invalid product data from search:', product);
                updateQRStatus('error', 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
                showMessage('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'error');
                return;
            }
            
            // Add to cart with validation
            addProductToCart(product.id, product.name, product.price, product.color || '', product.size || '');
            updateQRStatus('success', `âœ… ${product.name}`);
            showMessage(`ØªÙ… Ø¥Ø¶Ø§ÙØ©: ${product.name}`, 'success');
            
            // Clear QR input immediately
            const qrInput = document.getElementById('qrCodeInput');
            if (qrInput) {
                qrInput.value = '';
            }
            
            // Quick reset for next scan
            setTimeout(() => {
                updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
                if (qrInput) qrInput.focus();
            }, 1000);
            
        } else {
            updateQRStatus('error', `âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰: ${cleanQRCode}`);
            showMessage(`Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: ${cleanQRCode}`, 'error');
            
            // Reset for next scan
            setTimeout(() => {
                updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
                const qrInput = document.getElementById('qrCodeInput');
                if (qrInput) qrInput.focus();
            }, 2000);
        }
        
    } catch (error) {
        console.error('QR Search Error:', error);
        updateQRStatus('error', 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«');
        showMessage('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«', 'error');
        
        // Reset for next scan
        setTimeout(() => {
            updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
            const qrInput = document.getElementById('qrCodeInput');
            if (qrInput) qrInput.focus();
        }, 2000);
    } finally {
        // Release lock after completion
        delete window.qrProcessing[searchKey];
    }
}


// Keep barcode function for compatibility
function quickBarcode(code) {
   
    simpleQRSearch(code);
}



// Debug function to get all products and their QR codes
async function debugAllProducts() {
    console.log('ğŸ” Fetching all products for debugging...');
    
    try {
        const response = await fetch('/Cashier/GetAllProductsDebug');
        const result = await response.json();
        
        if (result.success) {
            
            console.table(result.products);
            
            // Show products with QR codes
            const withQR = result.products.filter(p => p.qrCode && p.qrCode.trim() !== '');
          
            console.table(withQR);
            
            // Show products without QR codes
            const withoutQR = result.products.filter(p => !p.qrCode || p.qrCode.trim() === '');
          
            console.table(withoutQR);
            
            return result.products;
        } else {
          
            return [];
        }
    } catch (error) {
        console.error('âŒ Error fetching products:', error);
        return [];
    }
}

// Test QR search with a specific code
async function testQRSearch(qrCode) {
   
    
    try {
        // Test exact search
      
        const exactResult = await searchProducts(qrCode, { searchMode: 'exact', includeOutOfStock: false });
       
        
        // Test standard search
       
        const standardResult = await searchProducts(qrCode, { searchMode: 'standard', includeOutOfStock: false });
       
        
        // Test with out of stock included
       
        const withOutOfStock = await searchProducts(qrCode, { searchMode: 'standard', includeOutOfStock: true });
      
        
        // Direct API call test
      
        const response = await fetch(`/Cashier/SearchProducts?term=${encodeURIComponent(qrCode)}&includeOutOfStock=true`);
        const apiResult = await response.json();
     
        
        return {
            exact: exactResult,
            standard: standardResult,
            withOutOfStock: withOutOfStock,
            directAPI: apiResult
        };
        
    } catch (error) {
    
        return null;
    }
}

// Update scanner statistics
function updateScannerStats(success = true) {
    try {
        // Update last scan time
        const now = new Date();
        const timeString = now.toLocaleTimeString('ar-EG', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        const lastScanElement = document.getElementById('lastScanTime');
        if (lastScanElement) {
            lastScanElement.textContent = timeString;
            lastScanElement.style.color = success ? '#28a745' : '#dc3545';
        }
        
        // Update daily scan count
        const dailyScansElement = document.getElementById('dailyScans');
        if (dailyScansElement) {
            let currentCount = parseInt(dailyScansElement.textContent) || 0;
            if (success) {
                currentCount++;
                dailyScansElement.textContent = currentCount;
                dailyScansElement.style.color = '#007bff';
                
                // Add animation for new scan
                dailyScansElement.style.transform = 'scale(1.3)';
                setTimeout(() => {
                    dailyScansElement.style.transform = 'scale(1)';
                }, 200);
            }
        }
        
        // Store stats in localStorage
        const today = now.toDateString();
        const statsKey = `scannerStats_${today}`;
        const stats = JSON.parse(localStorage.getItem(statsKey) || '{"total": 0, "successful": 0}');
        
        stats.total++;
        if (success) {
            stats.successful++;
        }
        
        localStorage.setItem(statsKey, JSON.stringify(stats));
        
    } catch (error) {
        console.error('âŒ Error updating scanner stats:', error);
    }
}

// Initialize scanner statistics display
function initializeScannerStats() {
    try {
        const today = new Date().toDateString();
        const statsKey = `scannerStats_${today}`;
        const stats = JSON.parse(localStorage.getItem(statsKey) || '{"total": 0, "successful": 0}');
        
        const dailyScansElement = document.getElementById('dailyScans');
        if (dailyScansElement) {
            dailyScansElement.textContent = stats.successful || 0;
        }
        
    
        
    } catch (error) {
        console.error('âŒ Error initializing scanner stats:', error);
    }
}

// Force show QR mode and ensure all elements are visible
function forceShowQRMode() {
    console.log('ğŸ”§ Force showing QR mode...');
    
    try {
        // Ensure QR mode is visible
        const qrScannerMode = document.getElementById('qrScannerMode');
        if (qrScannerMode) {
            qrScannerMode.style.display = 'block';
            qrScannerMode.style.visibility = 'visible';
            qrScannerMode.style.opacity = '1';
            console.log('âœ… QR Scanner mode forced visible');
        }
        
        // Ensure QR tab button is active
        const qrModeBtn = document.getElementById('qrModeBtn');
        if (qrModeBtn) {
            qrModeBtn.classList.add('active');
            console.log('âœ… QR Mode button activated');
        }
        
        // Ensure QR input is visible
        const qrInput = document.getElementById('qrCodeInput');
        if (qrInput) {
            qrInput.style.display = 'block';
            qrInput.style.visibility = 'visible';
            console.log('âœ… QR Input forced visible');
        }
        
        // Hide other search modes
        const nameSearchMode = document.getElementById('nameSearchMode');
        const advancedSearchMode = document.getElementById('advancedSearchMode');
        
        if (nameSearchMode) {
            nameSearchMode.style.display = 'none';
        }
        if (advancedSearchMode) {
            advancedSearchMode.style.display = 'none';
        }
        
        // Update current search mode
        currentSearchMode = 'qr';
        
   
        
    } catch (error) {
        console.error('âŒ Error forcing QR mode display:', error);
    }
}

// Check if user is interacting with customer or transaction elements
function isUserInteractingWithOtherElements() {
    const activeElement = document.activeElement;
    if (!activeElement) return false;
    
    // Check if user is working with customer fields
    const customerElements = [
        'customerPhone', 'customerName', 'customerAddress', 'customerNotes',
        'originalInvoiceNumber', 'reasonSelect'
    ];
    
    if (customerElements.includes(activeElement.id)) {
        return true;
    }
    
    // Check if user is working with cart or transaction elements
    const transactionElements = ['cartItems', 'processTransactionBtn'];
    if (transactionElements.some(id => activeElement.id === id || activeElement.closest(`#${id}`))) {
        return true;
    }
    
    // Check if user is typing in any input field
    if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT') {
        return true;
    }
    
    return false;
}

// Monitor QR mode visibility and fix if needed (less aggressive)
function startQRVisibilityMonitor() {
    // Only start one monitor
    if (window.qrVisibilityMonitor) {
        clearInterval(window.qrVisibilityMonitor);
    }
    
    window.qrVisibilityMonitor = setInterval(() => {
        if (currentSearchMode === 'qr' && !isUserInteractingWithOtherElements()) {
            const qrScannerMode = document.getElementById('qrScannerMode');
            
            // Only check if QR mode should be visible but isn't (less aggressive)
            if (qrScannerMode && qrScannerMode.style.display === 'none') {
               
                qrScannerMode.style.display = 'block';
                qrScannerMode.style.visibility = 'visible';
            }
        }
    }, 10000); // Check every 10 seconds (much less frequent)
    
  
}

// Manual fix for QR display issues
function fixQRDisplay() {
  
    
    try {
        // Force clear any CSS hiding
        const qrScannerMode = document.getElementById('qrScannerMode');
        const qrInput = document.getElementById('qrCodeInput');
        const qrStatus = document.getElementById('qrStatus');
        const clearBtn = document.getElementById('clearQRBtn');
        
        // Reset all QR elements
        [qrScannerMode, qrInput, qrStatus, clearBtn].forEach(element => {
            if (element) {
                element.style.display = 'block';
                element.style.visibility = 'visible';
                element.style.opacity = '1';
                element.style.position = '';
                element.style.left = '';
                element.style.top = '';
                element.style.transform = '';
            }
        });
        
        // Force QR mode
        forceShowQRMode();
        
        // Reinitialize if needed
        if (qrInput && !qrInput.hasAttribute('data-qr-initialized')) {
            initializeQRMode();
        }
        
        // Focus the input
        if (qrInput) {
            qrInput.focus();
        }
        
        showMessage('ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø¹Ø±Ø¶ Ù†Ø¸Ø§Ù… QR Ø¨Ù†Ø¬Ø§Ø­', 'success');
        console.log('âœ… QR display manually fixed');
        
    } catch (error) {
       
        showMessage('Ø®Ø·Ø£ ÙÙŠ Ø¥ØµÙ„Ø§Ø­ Ø¹Ø±Ø¶ QR', 'error');
    }
}

// Disable QR forcing for better user experience
function disableQRForcing() {
   
    
    try {
        // Stop the visibility monitor
        if (window.qrVisibilityMonitor) {
            clearInterval(window.qrVisibilityMonitor);
            window.qrVisibilityMonitor = null;
          
        }
        
        // Remove aggressive focus handling
        const qrInput = document.getElementById('qrCodeInput');
        if (qrInput) {
            qrInput.onblur = null; // Remove aggressive refocus
           
        }
        
        // Allow user to interact freely
        currentSearchMode = null; // Temporarily disable mode forcing
        
        showMessage('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø¥Ø¬Ø¨Ø§Ø± ÙˆØ¶Ø¹ QR - ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø¨Ø§Ù‚ÙŠ Ø§Ù„ØµÙØ­Ø© Ø¨Ø­Ø±ÙŠØ©', 'info');
      
        
    } catch (error) {
        console.error('âŒ Error disabling QR forcing:', error);
        showMessage('Ø®Ø·Ø£ ÙÙŠ Ø¥ÙŠÙ‚Ø§Ù Ø¥Ø¬Ø¨Ø§Ø± QR', 'error');
    }
}

// Update QR scanner status
function updateQRStatus(status, message) {
    const qrStatus = document.getElementById('qrStatus');
    if (!qrStatus) return;
    
    // Remove existing classes
    qrStatus.className = `status-${status}`;
    
    // Update content
    let icon = '';
    switch (status) {
        case 'loading':
            icon = '<i class="fas fa-circle-notch fa-spin"></i>';
            break;
        case 'success':
            icon = '<i class="fas fa-check-circle"></i>';
            break;
        case 'error':
            icon = '<i class="fas fa-exclamation-circle"></i>';
            break;
        case 'ready':
        default:
            icon = '<i class="fas fa-qrcode"></i>';
            break;
    }
    
    qrStatus.innerHTML = `${icon} <span class="status-text">${message}</span>`;
}

// Clear QR input
function clearQRInput() {
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput) {
        qrInput.value = '';
        qrInput.focus();
    }
    updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
}

// Advanced search with filters
async function performAdvancedSearch() {
    console.log('ğŸ”§ Performing advanced search...');
    
    // Get filter values (implement based on your form)
    const filters = {
        term: document.getElementById('advancedSearchTerm')?.value || '',
        category: document.getElementById('categoryFilter')?.value || '',
        color: document.getElementById('colorFilter')?.value || '',
        size: document.getElementById('sizeFilter')?.value || '',
        minPrice: parseFloat(document.getElementById('minPriceFilter')?.value) || null,
        maxPrice: parseFloat(document.getElementById('maxPriceFilter')?.value) || null,
        includeOutOfStock: document.getElementById('includeOutOfStock')?.checked || true,
        searchMode: document.getElementById('searchMode')?.value || 'standard'
    };
    
    try {
        const result = await searchProducts(filters.term, filters);
        
        if (result.success) {
            displayAdvancedSearchResults(result.products, result.searchInfo);
        } else {
            showMessage('âŒ ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªÙ‚Ø¯Ù…', 'error');
        }
    } catch (error) {
        console.error('âŒ Advanced search error:', error);
        showMessage('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªÙ‚Ø¯Ù…', 'error');
    }
}

// Display advanced search results
function displayAdvancedSearchResults(products, searchInfo) {
   
    
    // Implementation depends on your UI structure
    // This is a basic template
    
    const resultsContainer = document.getElementById('advancedSearchResults');
    if (!resultsContainer) return;
    
    let html = `
        <div class="search-results-header">
            <h5>ğŸ“Š Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« (${products.length})</h5>
            ${searchInfo.hasMoreResults ? '<small class="text-muted">ÙŠÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø¥Ø¶Ø§ÙÙŠØ©...</small>' : ''}
        </div>
        <div class="search-results-grid">
    `;
    
    products.forEach(product => {
        html += `
            <div class="product-card ${product.isAvailable ? 'available' : 'unavailable'}">
                <div class="product-header">
                    <h6 class="product-name">${escapeHtml(product.name)}</h6>
                    <span class="stock-badge ${product.isAvailable ? 'badge-success' : 'badge-danger'}">
                        ${product.stockStatus}
                    </span>
                </div>
                <div class="product-body">
                    <div class="price">ğŸ’° ${product.price.toFixed(2)} Ø¬Ù†ÙŠÙ‡</div>
                    <div class="quantity">ğŸ“¦ Ø§Ù„ÙƒÙ…ÙŠØ©: ${product.quantity}</div>
                    ${product.category ? `<div class="category">ğŸ“ ${escapeHtml(product.category)}</div>` : ''}
                    ${product.color ? `<div class="color">ğŸ¨ ${escapeHtml(product.color)}</div>` : ''}
                </div>
                <div class="product-actions">
                    ${product.isAvailable ? `
                        <button type="button" class="btn btn-primary btn-sm w-100" 
                                onclick="addProductToCart(${product.id}, '${escapeHtml(product.name)}', ${product.price}, '${product.color || ''}', '${product.size || ''}')">
                            <i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø³Ù„Ø©
                        </button>
                    ` : `
                        <button type="button" class="btn btn-secondary btn-sm w-100" disabled>
                            <i class="fas fa-ban"></i> ØºÙŠØ± Ù…ØªÙˆÙØ±
                        </button>
                    `}
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    resultsContainer.innerHTML = html;
}

// Test manual quantity update
function testManualUpdate(productName) {
  
    
    fetch(`/Cashier/SearchProducts?term=${encodeURIComponent(productName)}`)
        .then(response => response.json())
        .then(products => {
            if (products && products.length > 0) {
                const product = products[0];
                const newQuantity = prompt(`ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: ${product.name}\nğŸ”¢ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${product.quantity}\n\nØ£Ø¯Ø®Ù„ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:`, product.quantity + 5);
                
                if (newQuantity !== null && !isNaN(newQuantity)) {
                    // Send update request
                    return fetch('/Cashier/UpdateProductQuantity', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `productId=${product.id}&newQuantity=${newQuantity}&reason=Manual Test Update`
                    });
                }
            } else {
                alert('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬');
            }
        })
        .then(response => response?.json())
        .then(result => {
            if (result) {
                
                if (result.success) {
                    alert(`âœ… ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ù†Ø¬Ø§Ø­!\nğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬: ${result.productName}\nğŸ”¢ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©: ${result.oldQuantity}\nğŸ”¢ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©: ${result.newQuantity}\nğŸ’¾ SaveResult: ${result.saveResult}`);
                } else {
                    alert(`âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«: ${result.message}`);
                }
            }
        })
        .catch(error => {
            console.error('âŒ Error in manual update:', error);
            alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙŠØ¯ÙˆÙŠ');
        });
}



// ===============================================
// Mode Management
// ===============================================

// Legacy switchMode function - REMOVED
// This function has been removed as the mode selection section was removed from the UI

// Update mode status indicator
function updateModeStatus(modeInfo) {
    const statusIndicator = document.getElementById('modeStatusIndicator');
    const statusText = document.getElementById('modeStatusText');
    
    if (statusIndicator && statusText) {
        // Remove all alert classes
        statusIndicator.className = 'alert';
        
        // Add appropriate alert class based on mode
        statusIndicator.classList.add(`alert-${modeInfo.color}`);
        
        // Update text with mode information
        statusText.innerHTML = `
            ${modeInfo.icon} <strong>${modeInfo.name}</strong>: ${modeInfo.description}
        `;
        
        // Update icon
        const icon = statusIndicator.querySelector('i');
        if (icon) {
            icon.className = `fas fa-${getStatusIconName(modeInfo.color)} me-2`;
        }
    }
}

// Get status icon name based on color
function getStatusIconName(color) {
    const iconMap = {
        'success': 'check-circle',
        'warning': 'exclamation-triangle',
        'info': 'info-circle',
        'danger': 'times-circle'
    };
    return iconMap[color] || 'info-circle';
}

// Update cart title based on mode
function updateCartTitle(mode) {
    const cartTitle = document.getElementById('cartTitle');
    if (cartTitle) {
        const cartTitles = {
            'sale': 'ğŸ›’ Ø³Ù„Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª',
            'exchange': 'ğŸ”„ Ø³Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„',
            'return': 'â†©ï¸ Ø³Ù„Ø© Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹'
        };
        
        cartTitle.textContent = cartTitles[mode] || 'ğŸ›’ Ø³Ù„Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª';
    }
}

// Update mode button visual states
function updateModeButtons(activeMode) {
    try {
        // Remove active class from all mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to current mode button
        const targetBtn = document.getElementById(activeMode + 'ModeBtn');
        if (targetBtn) {
            targetBtn.classList.add('active');
        } else {
            console.warn('Button not found:', activeMode + 'ModeBtn');
        }
    } catch (error) {
        console.error('Error updating mode buttons:', error);
    }
}

// Enhanced show/hide exchange and return specific fields with animation
function toggleExchangeReturnFields(mode) {
    try {
        const fieldsDiv = document.getElementById('exchangeReturnFields');
        if (fieldsDiv) {
            if (mode === 'exchange' || mode === 'return') {
                // Show fields with animation
                fieldsDiv.style.display = 'block';
                fieldsDiv.classList.add('active');
                
                // Focus on invoice number field
                setTimeout(() => {
                    const invoiceInput = document.getElementById('originalInvoiceNumber');
                    if (invoiceInput) {
                        invoiceInput.focus();
                    }
                }, 300);
                
               
            } else {
                // Hide fields
                fieldsDiv.classList.remove('active');
                setTimeout(() => {
                    fieldsDiv.style.display = 'none';
                }, 300);
                
                // Clear fields when hiding
                clearExchangeReturnFields();
                
               
            }
        } else {
            console.warn('âš ï¸ exchangeReturnFields element not found');
        }
    } catch (error) {
        console.error('âŒ Error toggling exchange/return fields:', error);
    }
}

// Clear exchange/return specific fields
function clearExchangeReturnFields() {
    try {
        const fieldsToClean = [
            'originalInvoiceNumber',
            'reasonSelect'
        ];
        
        fieldsToClean.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.value = '';
                field.classList.remove('is-valid', 'is-invalid');
            }
        });
        
        // Clear checkboxes
        const checkboxes = [
            'includeShippingRefund',
            'exchangeWithDifference'
        ];
        
        checkboxes.forEach(checkboxId => {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = false;
            }
        });
        
        // Clear search results
        clearInvoiceSearchResults();
        
       
    } catch (error) {
        console.error('âŒ Error clearing exchange/return fields:', error);
    }
}

// Clear invoice search results
function clearInvoiceSearchResults() {
    const searchResult = document.getElementById('invoiceSearchResult');
    if (searchResult) {
        searchResult.style.display = 'none';
        searchResult.innerHTML = '';
    }
}

// ===============================================
// Search Mode Management
// ===============================================

// Switch search modes (QR, name, advanced)
function switchSearchMode(mode) {
  
    
    // Prevent switching to same mode
    if (currentSearchMode === mode) {
       
        return;
    }
    
    const searchModes = {
        'qr': 'Ù…Ø³Ø­ QR Code',
        'name': 'Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù…'
    };
    
    currentSearchMode = mode;
    
    // Clear any existing initialization flags for clean restart
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput && mode !== 'qr') {
        qrInput.removeAttribute('data-qr-initialized');
        qrInput.removeAttribute('data-scanner-initialized');
    }
    
    // Hide all search mode containers
    document.querySelectorAll('.search-mode').forEach(modeDiv => {
        modeDiv.style.display = 'none';
    });
    
    // Show the selected mode with force visibility
    const modeIds = {
        'qr': 'qrScannerMode',
        'name': 'nameSearchMode'
    };
    
    const targetMode = document.getElementById(modeIds[mode]);
   
    
    if (targetMode) {
        targetMode.style.display = 'block';
        targetMode.style.visibility = 'visible';
        targetMode.style.opacity = '1';
       
        
        // Special handling for QR mode
        if (mode === 'qr') {
            // Ensure all QR elements are visible
            const qrInput = document.getElementById('qrCodeInput');
            const qrStatus = document.getElementById('qrStatus');
            const clearBtn = document.getElementById('clearQRBtn');
            
            if (qrInput) {
                qrInput.style.display = 'block';
                qrInput.style.visibility = 'visible';
            }
            if (qrStatus) {
                qrStatus.style.display = 'block';
                qrStatus.style.visibility = 'visible';
            }
            if (clearBtn) {
                clearBtn.style.display = 'block';
                clearBtn.style.visibility = 'visible';
            }
        }
    } else {
        console.error(`âŒ Could not find mode element: ${modeIds[mode]}`);
    }
    
    // Update search tab buttons
    updateSearchTabButtons(mode);
    
    // Initialize mode-specific features with delay to ensure DOM is ready
    setTimeout(() => {
        initializeSearchMode(mode);
    }, 100);
    
    showMessage(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰: ${searchModes[mode] || mode}`, 'info');
}

// Update search tab button states
function updateSearchTabButtons(activeMode) {
    try {
        document.querySelectorAll('.search-tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const targetBtn = document.getElementById(activeMode + 'ModeBtn');
        if (targetBtn) {
            targetBtn.classList.add('active');
        }
    } catch (error) {
        console.error('Error updating search tab buttons:', error);
    }
}

// Initialize mode-specific features
function initializeSearchMode(mode) {
   
    
    switch (mode) {
        case 'qr':
            initializeQRMode();
            break;
        case 'name':
            initializeNameSearchMode();
            break;
        case 'advanced':
            initializeAdvancedSearchMode();
            break;
    }
}

// Initialize QR scanning mode for scanner devices
function initializeQRMode() {
    const qrInput = document.getElementById('qrCodeInput');
    if (qrInput && !qrInput.hasAttribute('data-qr-initialized')) {
        // Mark as initialized to prevent duplicate setup
        qrInput.setAttribute('data-qr-initialized', 'true');
        
        // Keep focus on input for scanner devices
        qrInput.focus();
        
        // Prevent focus loss (only when user isn't working elsewhere)
        qrInput.onblur = function() {
            setTimeout(() => {
                // Only refocus if user isn't interacting with other important elements
                if (currentSearchMode === 'qr' && !isUserInteractingWithOtherElements()) {
                    this.focus();
                }
            }, 100);
        };
        
        // Handle scanner input (most scanners send data followed by Enter)
        qrInput.onkeydown = function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const qrCode = this.value.trim();
                if (qrCode) {
                    processScannerInput(qrCode);
                    this.value = ''; // Clear immediately for next scan
                }
                return false;
            }
        };
        
        // Handle paste events (some scanners use clipboard)
        qrInput.onpaste = function(e) {
            e.preventDefault();
            const pastedData = (e.clipboardData || window.clipboardData).getData('text');
            if (pastedData && pastedData.trim()) {
                processScannerInput(pastedData.trim());
                this.value = '';
            }
        };
        
        // Auto-detect scanner input patterns
        let scanBuffer = '';
        let scanTimeout = null;
        
        qrInput.oninput = function() {
            const currentValue = this.value;
            
            // Clear any existing timeout
            if (scanTimeout) {
                clearTimeout(scanTimeout);
            }
            
            // If input is fast (scanner-like), accumulate
            if (currentValue.length > scanBuffer.length + 3) {
                // Fast input detected - likely scanner
                scanBuffer = currentValue;
                
                // Process after short delay to ensure complete scan
                scanTimeout = setTimeout(() => {
                    if (this.value === scanBuffer && scanBuffer.length >= 6) {
                        processScannerInput(scanBuffer);
                        this.value = '';
                        scanBuffer = '';
                    }
                }, 100);
            } else {
                // Normal typing - update buffer
                scanBuffer = currentValue;
                
                // If manually typed and looks complete, process after longer delay
                if (currentValue.length >= 8) {
                    scanTimeout = setTimeout(() => {
                        if (this.value === currentValue && currentValue.length >= 8) {
                            processScannerInput(currentValue);
                            this.value = '';
                        }
                    }, 1000);
                }
            }
        };
        
        // Keep input active and ready (only if not already set) - with user interaction check
        if (!qrInput.hasAttribute('data-scanner-initialized')) {
            qrInput.setAttribute('data-scanner-initialized', 'true');
            
            setInterval(() => {
                // Only refocus if user is not actively interacting with other elements
                if (currentSearchMode === 'qr' && 
                    document.activeElement !== qrInput && 
                    !isUserInteractingWithOtherElements()) {
                    qrInput.focus();
                }
            }, 5000); // Increased frequency to allow more user interaction
        }
        
        // Initialize scanner statistics (only once)
        if (!qrInput.hasAttribute('data-stats-initialized')) {
            qrInput.setAttribute('data-stats-initialized', 'true');
            initializeScannerStats();
        }
        
        // Start visibility monitor (passive mode)
        startQRVisibilityMonitor();
        
      
    } else if (qrInput) {
        // Already initialized, just ensure visibility (don't force focus)
        const qrScannerMode = document.getElementById('qrScannerMode');
        if (qrScannerMode && qrScannerMode.style.display === 'none') {
            qrScannerMode.style.display = 'block';
        }
      
    }
}

// Initialize name search mode with live search
function initializeNameSearchMode() {
    const nameInput = document.getElementById('productNameInput');
    const resultsContainer = document.getElementById('nameSearchResults');
    
    if (nameInput && resultsContainer) {
        nameInput.focus();
        
        // Initialize live search
        initializeLiveSearch(nameInput, resultsContainer, function(productId, productName, productPrice, productColor, productSize) {
            // Add selected product to cart
            addProductToCart(productId, productName, productPrice, productColor, productSize);
        });
        
       
    }
}

// Initialize advanced search mode
function initializeAdvancedSearchMode() {
   
    
    // Load categories for filter
    loadSearchFilters();
    
    // Add event listeners for real-time search
    const advancedTerm = document.getElementById('advancedSearchTerm');
    if (advancedTerm) {
        advancedTerm.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                performAdvancedSearch();
            }
        });
    }
    
 
}

// Load search filters (categories, colors, etc.)
async function loadSearchFilters() {
    try {
        const response = await fetch('/Cashier/GetCategories');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.categories) {
            // Populate category filter
            const categoryFilter = document.getElementById('categoryFilter');
            if (categoryFilter) {
                categoryFilter.innerHTML = '<option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ØµÙ†Ø§Ù</option>';
                data.categories.forEach(category => {
                    categoryFilter.innerHTML += `<option value="${category}">ğŸ·ï¸ ${category}</option>`;
                });
            }
            
          
        } else {
          
        }
    } catch (error) {
    
        
        // Fallback - use default categories
        const categoryFilter = document.getElementById('categoryFilter');
        if (categoryFilter) {
            categoryFilter.innerHTML = `
                <option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ØµÙ†Ø§Ù</option>
                <option value="Ù…Ù„Ø§Ø¨Ø³">ğŸ‘• Ù…Ù„Ø§Ø¨Ø³</option>
                <option value="Ø£Ø­Ø°ÙŠØ©">ğŸ‘Ÿ Ø£Ø­Ø°ÙŠØ©</option>
                <option value="Ø¥ÙƒØ³Ø³ÙˆØ§Ø±Ø§Øª">ğŸ’ Ø¥ÙƒØ³Ø³ÙˆØ§Ø±Ø§Øª</option>
                <option value="Ø­Ù‚Ø§Ø¦Ø¨">ğŸ‘œ Ø­Ù‚Ø§Ø¦Ø¨</option>
                <option value="Ø¹Ø·ÙˆØ±">ğŸŒ¸ Ø¹Ø·ÙˆØ±</option>
                <option value="Ø£Ø®Ø±Ù‰">ğŸ“¦ Ø£Ø®Ø±Ù‰</option>
            `;
        }
    }
}

// Clear product name search
function clearProductNameSearch() {
    const nameInput = document.getElementById('productNameInput');
    const resultsContainer = document.getElementById('nameSearchResults');
    
    if (nameInput) {
        nameInput.value = '';
        nameInput.focus();
    }
    
    if (resultsContainer) {
        resultsContainer.style.display = 'none';
        resultsContainer.innerHTML = '';
    }
}

// Show popular products
async function showPopularProducts() {
    try {
      
        
        // Get recent/popular products (no search term = recent products)
        const result = await searchProducts('', { 
            includeOutOfStock: false, 
            limit: 10 
        });
        
        if (result.success && result.products.length > 0) {
            const resultsContainer = document.getElementById('nameSearchResults');
            if (resultsContainer) {
                displaySearchResults(result.products, resultsContainer, function(productId, productName, productPrice) {
                    addProductToCart(productId, productName, productPrice);
                });
                resultsContainer.style.display = 'block';
            }
            
            showMessage(`ğŸ”¥ ØªÙ… Ø¹Ø±Ø¶ ${result.products.length} Ù…Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©`, 'success');
        } else {
            showMessage('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª Ø´Ø§Ø¦Ø¹Ø© Ù…ØªØ§Ø­Ø©', 'warning');
        }
    } catch (error) {
      
        showMessage('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©', 'error');
    }
}

// Clear advanced search filters
function clearAdvancedFilters() {
    // Clear all input fields
    document.getElementById('advancedSearchTerm').value = '';
    document.getElementById('categoryFilter').value = '';
    document.getElementById('colorFilter').value = '';
    document.getElementById('minPriceFilter').value = '';
    document.getElementById('maxPriceFilter').value = '';
    document.getElementById('includeOutOfStock').checked = true;
    document.getElementById('searchMode').value = 'standard';
    
    // Clear results
    const resultsContainer = document.getElementById('advancedSearchResults');
    if (resultsContainer) {
        resultsContainer.innerHTML = '';
    }
    
    showMessage('ğŸ§¹ ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙ„Ø§ØªØ±', 'info');
}

// ===============================================
// Cart Management
// ===============================================

// Clear shopping cart
function clearCart() {
    if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù…Ù† Ø§Ù„Ø³Ù„Ø©ØŸ')) {
        const previousCount = cart.length;
        cart = [];
        
        showMessage('ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø³Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
    
        
        // Update cart display if function exists
        if (typeof updateCartDisplay === 'function') {
            updateCartDisplay();
        }
        
        // Update cart summary if function exists
        if (typeof updateCartSummary === 'function') {
            updateCartSummary();
        }
    }
}

// Add item to cart
function addToCart(product, quantity = 1) {
    try {
        if (!product || !product.id) {
           
            return;
        }
        
        const existingItem = cart.find(item => item.id === product.id);
        
        if (existingItem) {
            existingItem.quantity += quantity;
            
            // Recalculate total with discount
            const itemSubTotal = Math.abs(existingItem.price * existingItem.quantity);
            const discountAmount = existingItem.discount || 0; // Direct amount
            existingItem.total = Math.round((itemSubTotal - discountAmount) * 100) / 100;
            
         
        } else {
            cart.push({
                id: product.id,
                name: product.name,
                price: product.price,
                quantity: quantity,
                stock: product.stock || 0,
                total: Math.round((product.price * quantity) * 100) / 100, // Round to 2 decimal places
                discount: 0
            });
           
        }
        
        alert(`âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© ${product.name} Ø¥Ù„Ù‰ Ø§Ù„Ø³Ù„Ø©`);
        
    } catch (error) {
        console.error('Error adding to cart:', error);
        alert('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬');
    }
}

// ===============================================
// Customer Management
// ===============================================

// Search customer by phone number
async function searchCustomerByPhone() {
    try {
        const phoneInput = document.getElementById('customerPhone');
        if (!phoneInput) {
            console.error('customerPhone input not found');
            showMessage('âŒ Ø­Ù‚Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'error');
            return;
        }
        
        const phone = phoneInput.value.trim();
        if (!phone) {
            showMessage('âŒ Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ', 'error');
            phoneInput.focus();
            return;
        }
        
        // Basic phone validation - just check if it's not empty
        if (phone.length < 7) {
            showMessage('âŒ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 7 Ø£Ø±Ù‚Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'error');
            phoneInput.focus();
            return;
        }
        
        // Show loading state
        const searchBtn = document.getElementById('searchCustomerBtn');
        
        searchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¨Ø­Ø«...';
        searchBtn.disabled = true;
        
        // Show loading in phone input
        if (phoneInput) {
            phoneInput.placeholder = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...';
            phoneInput.disabled = true;
        }
        
        showMessage(`ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„: ${phone}`, 'info');
        console.log('Searching for customer with phone:', phone);
        
        // Make AJAX call to search for the customer
        const response = await fetch(`/Cashier/SearchCustomerByPhone?phone=${encodeURIComponent(phone)}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
            // Customer found - fill the form
            const customer = data.customer;
            fillCustomerDataFromSearch(customer);
            
            // Update customer select dropdown
            updateCustomerSelect(customer);
            
            showMessage(`âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…ÙŠÙ„: ${customer.name}`, 'success');
            updateCustomerStatus(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù…ÙŠÙ„: ${customer.name}`, 'success');
            animateCustomerFilled();
            
           
        } else {
            // Customer not found
            showMessage(data.message || 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…ÙŠÙ„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù…', 'warning');
            updateCustomerStatus('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…ÙŠÙ„', 'warning');
            
        }
        
    } catch (error) {
        console.error('Error in searchCustomerByPhone:', error);
        showMessage('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„', 'error');
        updateCustomerStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«', 'error');
    } finally {
        // Reset button state
        const searchBtn = document.getElementById('searchCustomerBtn');
        searchBtn.innerHTML = '<i class="fas fa-search"></i> Ø¨Ø­Ø«';
        searchBtn.disabled = false;
        
        // Reset phone input state
        if (phoneInput) {
            phoneInput.placeholder = '01xxxxxxxxx';
            phoneInput.disabled = false;
        }
    }
}

// ===============================================
// QR Scanner
// ===============================================


// ===============================================
// Transaction Processing
// ===============================================

// Process transaction (main action)
async function processTransaction() {
    try {
       
        
        // Enhanced validation
        if (!cart || !Array.isArray(cart) || cart.length === 0) {
            console.error('âŒ Cart validation failed:', {
                cart: cart,
                isArray: Array.isArray(cart),
                length: cart ? cart.length : 'undefined'
            });
            alert('âŒ Ø§Ù„Ø³Ù„Ø© ÙØ§Ø±ØºØ©! ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª Ø£ÙˆÙ„Ø§Ù‹');
            return;
        }
        
      
        
        // Check customer selection or new customer data
        const collectedCustomerData = collectCustomerData();
        const hasSelectedCustomer = collectedCustomerData.customerId && collectedCustomerData.customerId !== '0';
        const hasNewCustomerData = collectedCustomerData.name.trim() && collectedCustomerData.phone.trim();
        
       
        
        // Check if return items exist and original invoice is needed
        const hasReturnItems = cart.some(item => item.quantity < 0);
        if (hasReturnItems) {
            const originalInvoiceInput = document.getElementById('originalInvoiceNumber');
            // Original invoice is optional in the new system
            if (originalInvoiceInput && originalInvoiceInput.value.trim()) {
               
            } else {
               
            }
        }
        
       
        
        // Collect customer data
        const finalCustomerData = collectCustomerData();
      
        
        // Prepare transaction data
        const transactionData = prepareTransactionData(finalCustomerData);
     
        
        // Check if prepareTransactionData returned null
        if (!transactionData) {
           
            return;
        }
        
        // Check for duplicate numbers before sending
        const invoiceNumber = document.getElementById('invoiceNumber')?.value?.trim();
        const orderNumber = document.getElementById('orderNumber')?.value?.trim();
        
        if (invoiceNumber) {
            const invoiceCheck = await checkInvoiceNumberDuplicate(invoiceNumber);
            if (invoiceCheck && invoiceCheck.exists) {
                alert('âŒ Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„! ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ù‚Ù… Ø¢Ø®Ø±');
                return;
            }
        }
        
        if (orderNumber) {
            const orderCheck = await checkOrderNumberDuplicate(orderNumber);
            if (orderCheck && orderCheck.exists) {
                alert('âŒ Ø±Ù‚Ù… Ø§Ù„Ø£Ù…Ø± Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„! ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ù‚Ù… Ø¢Ø®Ø±');
                return;
            }
        }
        
        // Send to server using the prepared transaction data
        
        
        // Show transaction summary before sending
        const grandTotal = getCartGrandTotal();
        const amountPaid = Math.round(parseFloat(document.getElementById('amountPaid')?.value || 0) * 100) / 100;
        const remaining = grandTotal - amountPaid;
        
        console.log('ğŸ’° Transaction Summary:', {
            grandTotal: grandTotal.toFixed(2),
            amountPaid: amountPaid.toFixed(2),
            remaining: remaining.toFixed(2),
            items: cart.map(item => ({
                name: item.name,
                quantity: item.quantity,
                price: item.price,
                discount: item.discount || 0,
                total: Math.abs(item.total || (item.price * item.quantity)).toFixed(2),
                mode: item.quantity < 0 ? 'return' : 'sale'
            }))
        });
        
        // Show user-friendly summary
        if (remaining > 0) {
            showMessage(`ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${grandTotal.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${amountPaid.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${remaining.toFixed(2)} Ø¬.Ù…`, 'info');
        } else if (remaining < 0) {
            showMessage(`ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${grandTotal.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${amountPaid.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ø¨Ø§Ù‚ÙŠ: ${Math.abs(remaining).toFixed(2)} Ø¬.Ù…`, 'success');
        } else {
            showMessage(`âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${grandTotal.toFixed(2)} Ø¬.Ù… | ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„`, 'success');
        }
        
        // Log detailed calculation for debugging
        console.log('ğŸ” Detailed calculation for transaction:', {
            cartItems: cart.length,
            saleItems: cart.filter(item => item.quantity > 0).length,
            returnItems: cart.filter(item => item.quantity < 0).length,
            totalDiscount: cart.reduce((sum, item) => sum + (item.discount || 0), 0).toFixed(2)
        });
        
        sendTransactionToServer(transactionData);
        
    } catch (error) {
        console.error('Error in processTransaction:', error);
        alert('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©');
    }
}

// Collect customer data from form
function collectCustomerData() {
    const customerSelect = document.getElementById('customerSelect');
    const customerName = document.getElementById('customerName');
    
    // Try multiple phone field IDs (customerPhone for search, customerPhoneInput for new customer)
    const customerPhone = document.getElementById('customerPhone');
    const customerPhoneInput = document.getElementById('customerPhoneInput');
    const phoneValue = customerPhone?.value || customerPhoneInput?.value || '';
    
    // Get all customer fields
    const customerEmail = document.getElementById('customerEmail');
    const customerAdditionalPhone = document.getElementById('customerAdditionalPhone');
    const customerGovernorate = document.getElementById('customerGovernorate');
    const customerDistrict = document.getElementById('customerDistrict');
    const customerDetailedAddress = document.getElementById('customerDetailedAddress');
    
    const result = {
        customerId: customerSelect?.value || null,
        name: customerName?.value?.trim() || '',
        phone: phoneValue.trim(),
        email: customerEmail?.value?.trim() || '',
        additionalPhone: customerAdditionalPhone?.value?.trim() || '',
        governorate: customerGovernorate?.value || '',
        district: customerDistrict?.value?.trim() || '',
        detailedAddress: customerDetailedAddress?.value?.trim() || '',
        address: customerDetailedAddress?.value?.trim() || ''
    };
    
    console.log('ğŸ“‹ collectCustomerData result:', result);
    return result;
}

// Prepare transaction data for sending to server
function prepareTransactionData(customerData) {
    console.log('ğŸ”§ Preparing transaction data...');
    console.log('ğŸ›’ Current cart:', cart);
    console.log('ğŸ›’ Cart length:', cart.length);
    
    if (!cart || cart.length === 0) {
        console.error('âŒ Cart is empty in prepareTransactionData!');
        alert('âŒ Ø§Ù„Ø³Ù„Ø© ÙØ§Ø±ØºØ©! ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª Ø£ÙˆÙ„Ø§Ù‹');
        return null;
    }
    
    // Calculate totals
    let subTotal = 0;
    let totalDiscount = 0;
    
    const items = cart.map(item => {
        // Validate that we have a proper productId (not the cart item id)
        let actualProductId = item.productId;
        
        // If productId looks like a timestamp or matches cart item id, try to find real product ID
        if (!actualProductId || actualProductId === item.id || actualProductId.toString().length > 10) {
            console.warn('âš ï¸ Suspicious productId for cart item:', item);
            console.warn('âš ï¸ Will try to use ProductName for server-side lookup');
            // Use a sentinel value that server can detect and handle via ProductName lookup
            actualProductId = 0;
        }
        
        const itemSubTotal = Math.abs(item.price * item.quantity);
        const itemDiscount = item.discount || 0; // Direct amount, not percentage
        const itemTotal = itemSubTotal - itemDiscount;
        
        subTotal += (item.quantity < 0 ? -itemSubTotal : itemSubTotal); // Use subtotal for calculation
        // Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹: Ù„Ø§ Ù†Ø±Ø³Ù„ Ø§Ù„Ø®ØµÙ… (Ø§Ù„Ø®ØµÙ… Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø§ ÙŠÙØ¹ØªØ¨Ø± Ø®Ø³Ø§Ø±Ø©)
        totalDiscount += (item.quantity < 0 ? 0 : itemDiscount);
        
        return {
            ProductId: actualProductId, // Use the validated/corrected product ID
            ProductName: item.name,
            Color: item.color || null, // Color information
            Size: item.size || null, // Size information
            Quantity: item.quantity, // Keep negative for returns
            Price: item.price,
            Discount: item.discount || 0, // Ø­ÙØ¸ Ø§Ù„Ø®ØµÙ… ÙƒÙ…Ø§ Ù‡Ùˆ
            Notes: item.notes || null // Optional notes
        };
    });
    
    // Get additional fields (simplified)
    const policyNumber = document.getElementById('policyNumber')?.value || '';
    const invoiceStatus = document.getElementById('invoiceStatus')?.value || 3; // Default to Paid
    const orderOrigin = document.getElementById('orderOrigin')?.value || 7; // Default to PhysicalStore
    const paymentMethod = document.getElementById('paymentMethod')?.value || '';
    const shippingCost = parseFloat(document.getElementById('shippingCost')?.value || 0);
    const shippingType = document.getElementById('shippingType')?.value || null;
    const invoiceNumber = document.getElementById('invoiceNumber')?.value || '';
    const orderNumber = document.getElementById('orderNumber')?.value || '';
    const originalInvoiceNumber = document.getElementById('originalInvoiceNumber')?.value || '';
    const returnNotes = document.getElementById('returnNotes')?.value || '';
    
    // Get the payment amount
    const amountPaidInput = document.getElementById('amountPaid');
    const amountPaid = Math.round(parseFloat(amountPaidInput?.value || 0) * 100) / 100;
    
    // Determine invoice type based on total amount
    const invoiceType = subTotal < 0 ? 2 : 1; // 2 = Return, 1 = Sale
    const finalTotal = subTotal + (subTotal >= 0 ? shippingCost : 0);
    
    const transactionDataResult = {
        // Customer information - matching C# property names exactly
        CustomerId: parseInt(customerData.customerId) || 0,
        CustomerName: customerData.name || '',
        CustomerPhone: customerData.phone || '',
        CustomerEmail: customerData.email || '',
        CustomerAdditionalPhone: customerData.additionalPhone || '',
        CustomerGovernorate: customerData.governorate || '',
        CustomerDistrict: customerData.district || '',
        CustomerDetailedAddress: customerData.detailedAddress || '',
        CustomerAddress: customerData.address || '',
        
        // Transaction details
        Items: items, // Capital I to match C# model
        AmountPaid: amountPaid,
        
        // Invoice information - matching C# property names exactly
        InvoiceNumber: invoiceNumber,
        OrderNumber: orderNumber,
        PolicyNumber: policyNumber,
        InvoiceStatus: parseInt(invoiceStatus) || 3, // Default to Paid
        OrderOrigin: parseInt(orderOrigin) || 7,
        PaymentMethod: paymentMethod,
        ShippingCost: subTotal >= 0 ? shippingCost : 0, // No shipping for returns
        ShippingType: shippingType ? parseInt(shippingType) : null,
        InvoiceType: invoiceType,
        
        // Optional reference and notes - matching C# property names exactly
        OriginalInvoiceNumber: originalInvoiceNumber,
        Notes: returnNotes,
        
        // Cashier information
        CashierName: document.getElementById('cashierName')?.textContent?.trim() || ''
    };
    
    console.log('âœ… Transaction data prepared successfully');
    console.log('ğŸ“Š Final items count:', transactionDataResult.Items.length);
    console.log('ğŸ“Š Final transaction data:', transactionDataResult);
    
    return transactionDataResult;
}

// Convert mode to invoice type
function getInvoiceTypeFromMode(mode) {
    switch (mode) {
        case 'sale': return 1; // Sale
        case 'exchange': return 2; // Exchange  
        case 'return': return 3; // Return
        default: return 1; // Default to Sale
    }
}

// Get mode name in Arabic
function getModeName(mode) {
    switch (mode) {
        case 'sale': return 'Ø§Ù„Ø¨ÙŠØ¹';
        case 'exchange': return 'Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„';
        case 'return': return 'Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹';
        default: return 'Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©';
    }
}

// Send transaction to server
function sendTransactionToServer(transactionData) {
    console.log('ğŸš€ Sending transaction to server...');
    console.log('ğŸ“¦ Transaction data being sent:', transactionData);
    
    // Simple validation
    if (!transactionData.Items || transactionData.Items.length === 0) {
        console.error('âŒ No items in transaction!');
        alert('âŒ Ø®Ø·Ø£: Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©');
        return;
    }
    
    // Show loading message
    const loadingMessage = 'â³ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø®Ø§Ø¯Ù…...';
    showMessage(loadingMessage, 'info');
    
    // Use only the main endpoint
    const endpoint = '/Cashier/ProcessTransaction';
    console.log(`ğŸ“¤ Using endpoint: ${endpoint}`);
    
    // Send POST request
    const jsonData = JSON.stringify(transactionData);
    console.log('ğŸ“¤ JSON being sent to server:', jsonData);
    
    fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        },
        body: jsonData
    })
    .then(response => {
        console.log('ğŸ“¨ Server response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(result => {
        console.log('âœ… Server response:', result);
        console.log('ğŸ“Š Result success status:', result.success);
        console.log('ğŸ“Š Result message:', result.message);
        
        if (result.success) {
            console.log('ğŸ‰ Calling handleTransactionSuccess...');
        handleTransactionSuccess(result);
        } else {
            console.log(`âŒ ${endpoint} failed with message: ${result.message}`);
            
            handleTransactionError(new Error(result.message || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error(`âŒ Transaction failed on ${endpoint}:`, error);
        
        handleTransactionError(error);
    });
}

// Handle successful transaction
function handleTransactionSuccess(result) {
    console.log('ğŸ‰ Transaction successful!', result);
    console.log('ğŸ‰ handleTransactionSuccess called with:', JSON.stringify(result, null, 2));
    
    // Double check success status
    if (!result.success) {
        console.error('âŒ Result shows success=false but passed to success handler');
        handleTransactionError(new Error(result.message || 'Transaction failed'));
        return;
    }
    
    console.log('âœ… Success status confirmed, proceeding with transaction completion...');
    
    // Log updated product quantities for verification
    if (result.updatedProducts && result.updatedProducts.length > 0) {
        console.log('ğŸ“Š Updated Product Quantities:');
        result.updatedProducts.forEach(product => {
            console.log(`   â€¢ ${product.productName} (ID: ${product.productId})`);
            console.log(`     â””â”€ New Quantity: ${product.newQuantity} (Change: ${product.quantityChange > 0 ? '+' : ''}${product.quantityChange})`);
        });
    }
    
    // Show enhanced message with return information
    let baseMessage = `âœ… ØªÙ… Ø¥Ù†Ø¬Ø§Ø² ${getModeName(getCurrentMode())} Ø¨Ù†Ø¬Ø§Ø­!\nØ±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${result.invoiceNumber || 'ØºÙŠØ± Ù…ØªØ§Ø­'}`;
    
    console.log('ğŸ“¢ Preparing success message:', baseMessage);
    
    // Add return warning if applicable
    if (result.hasReturns && result.returnedItems && result.returnedItems.length > 0) {
        baseMessage += '\n\nâš ï¸ ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ù…Ø±ØªØ¬Ø¹Ø§Øª:';
        result.returnedItems.forEach(item => {
            baseMessage += `\nâ€¢ ${item.productName}: ${item.quantity} Ù‚Ø·Ø¹Ø©`;
        });
        baseMessage += '\n\nğŸ”§ ØªØ°ÙƒÙŠØ±: Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ÙƒÙ…ÙŠØ§Øª Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…Ø±ØªØ¬Ø¹Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù…Ù† ØµÙØ­Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª';
        console.log('ğŸ“¢ Showing warning message for returns...');
        showMessage(baseMessage, 'warning', 8000); // Ø±Ø³Ø§Ù„Ø© Ø£Ø·ÙˆÙ„
    } else {
        console.log('ğŸ“¢ Showing success message...');
        showMessage(baseMessage, 'success');
    }
    
    // Also show an alert as backup
    alert('âœ… ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­!\n' + (result.message || 'Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§ÙƒØªÙ…Ù„Øª'));
    
    // Verify inventory updates for all transactions
    if (result.updatedProducts && result.updatedProducts.length > 0) {
        console.log('ğŸ” Verifying inventory updates...');
        verifyInventoryUpdatesFromResult(result.updatedProducts);
    }
    
    // Clear cart
    cart = [];
    window.cart = cart;
    
    // Clear number status
    clearInvoiceNumberStatus();
    clearOrderNumberStatus();
    
    updateCartDisplay();
    updateCartSummary();
    
    // Reset form
    resetTransactionForm();
    
    console.log('ğŸ§¹ Transaction completed and form reset');
}

// Verify inventory updates after return
function verifyInventoryUpdates() {
    console.log('ğŸ” Starting inventory verification...');
    
    cart.forEach(async (item, index) => {
        if (item.quantity < 0) { // Return item
            try {
                // We need to find the product by name since we don't have productId
                const response = await fetch(`/Cashier/SearchProducts?term=${encodeURIComponent(item.name)}`);
                const products = await response.json();
                
                if (products && products.length > 0) {
                    const product = products.find(p => p.name === item.name);
                    if (product) {
                        console.log(`ğŸ“¦ Product: ${product.name}, Current Quantity: ${product.quantity}, Returned: ${Math.abs(item.quantity)}`);
                        
                        // Show verification message
                        setTimeout(() => {
                            showMessage(`ğŸ“¦ ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚: ${product.name} - Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${product.quantity}`, 'info');
                        }, index * 1000);
                    }
                }
            } catch (error) {
                console.error('âŒ Error verifying inventory:', error);
            }
        }
    });
}

// Handle transaction error
function handleTransactionError(error) {
    console.error('ğŸ’¥ Transaction error:', error);
    
    let errorMessage = 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©';
    if (error.message) {
        // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
        errorMessage = error.message;
    }
    
    showMessage(errorMessage, 'error');
}

// Reset transaction form after completion
function resetTransactionForm() {
    // Reset additional fields
    const fieldsToReset = [
        'policyNumber',
        'invoiceStatus',
        'paymentMethod', 
        'shippingCost',
        'shippingType',
        'invoiceNumber',
        'orderNumber',
        'originalInvoiceNumber',
        'returnReason'
    ];
    
    fieldsToReset.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
            field.value = '';
        }
    });
    
    // Reset numbers generation flag
    window.numbersGenerated = false;
    
    // Reset order origin to default
    const orderOrigin = document.getElementById('orderOrigin');
    if (orderOrigin) {
        orderOrigin.value = 'other';
    }
    
    // Clear customer data
    clearCustomerData();
    
    // Return to sale mode
    isReturnMode = false;
    
    // Clear number status
    clearInvoiceNumberStatus();
    clearOrderNumberStatus();
    
    console.log('ğŸ”„ Form reset completed');
}

// Verify inventory updates from transaction result
function verifyInventoryUpdatesFromResult(updatedProducts) {
    console.log('ğŸ§ª Starting inventory verification...');
    
    // Display verification results
    updatedProducts.forEach(product => {
        const changeType = product.quantityChange > 0 ? 'Ø¨ÙŠØ¹' : 'Ø¥Ø±Ø¬Ø§Ø¹';
        const changeAmount = Math.abs(product.quantityChange);
        
        console.log(`âœ… VERIFIED: ${product.productName}`);
        console.log(`   â””â”€ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${product.newQuantity}`);
        console.log(`   â””â”€ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: ${changeType} (${changeAmount} Ù‚Ø·Ø¹Ø©)`);
        
        // Check if quantities make sense
        if (product.quantityChange > 0 && product.newQuantity >= 0) {
            console.log(`   â””â”€ âœ… Ø¨ÙŠØ¹ ØµØ­ÙŠØ­: ØªÙ… ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®Ø²ÙˆÙ†`);
        } else if (product.quantityChange < 0 && product.newQuantity >= 0) {
            console.log(`   â””â”€ âœ… Ø¥Ø±Ø¬Ø§Ø¹ ØµØ­ÙŠØ­: ØªÙ… Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†`);
        } else {
            console.warn(`   â””â”€ âš ï¸ ØªØ­Ø°ÙŠØ±: ÙƒÙ…ÙŠØ© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©`);
        }
    });
    
    console.log('âœ… Inventory verification completed');
}

// Manual test function for checking product quantity
async function testProductQuantity(productId) {
    try {
        console.log(`ğŸ§ª Testing product quantity for ID: ${productId}`);
        
        const response = await fetch(`/Cashier/GetRealTimeProductInfo?productId=${productId}`);
        const result = await response.json();
        
        if (result.success) {
            console.log('ğŸ“Š Real-time Product Info:');
            console.log(`   â€¢ Name: ${result.product.name}`);
            console.log(`   â€¢ Current Quantity: ${result.product.quantity}`);
            console.log(`   â€¢ Price: ${result.product.price}`);
            console.log(`   â€¢ Category: ${result.product.category || 'N/A'}`);
            
            if (result.recentTransactions && result.recentTransactions.length > 0) {
                console.log('ğŸ“ˆ Recent Transactions:');
                result.recentTransactions.forEach((tx, index) => {
                    console.log(`   ${index + 1}. Quantity: ${tx.quantity}, Total: ${tx.totalPrice}, Date: ${new Date(tx.date).toLocaleString()}`);
                });
            }
        } else {
            console.error('âŒ Error:', result.message);
        }
    } catch (error) {
        console.error('âŒ Test failed:', error);
    }
}

// Export test function to global scope
window.testProductQuantity = testProductQuantity;

// Test cart summary function
function testCartSummary() {
    console.log('ğŸ§ª Testing cart summary...');
    
    // Test if summary elements exist
    const summaryElements = ['subtotal', 'totalDiscount', 'grandTotal'];
    summaryElements.forEach(id => {
        const element = document.getElementById(id);
        console.log(`Element ${id}:`, element ? 'âœ… Found' : 'âŒ Missing');
    });
    
    // Test manual update
    updateSummaryElement('subtotal', '100.00 Ø¬.Ù…');
    updateSummaryElement('totalDiscount', '10.00 Ø¬.Ù…');
    updateSummaryElement('grandTotal', '90.00 Ø¬.Ù…');
    
    console.log('Cart contents:', cart);
    updateCartSummary();
}

// Export test function
window.testCartSummary = testCartSummary;

// Test all cart functions
function testCartFunctions() {
    console.log('ğŸ§ª Testing all cart functions...');
    
    // Test function availability
    const requiredFunctions = [
        'updateCartDisplay',
        'updateCartSummary', 
        'updateProcessButtonState',
        'addProductToCart',
        'clearCart'
    ];
    
    requiredFunctions.forEach(funcName => {
        const available = typeof window[funcName] === 'function';
        console.log(`${funcName}: ${available ? 'âœ… Available' : 'âŒ Missing'}`);
    });
    
    // Test elements
    const requiredElements = [
        'processTransactionBtn',
        'subtotal',
        'totalDiscount', 
        'grandTotal',
        'cartItems'
    ];
    
    requiredElements.forEach(id => {
        const element = document.getElementById(id);
        console.log(`Element ${id}: ${element ? 'âœ… Found' : 'âŒ Missing'}`);
    });
    
    console.log('Cart contents:', cart);
    console.log('Return mode:', isReturnMode);
}

// Export comprehensive test function
window.testCartFunctions = testCartFunctions;

// Test customer data collection and validation
function testCustomerValidation() {
    console.log('ğŸ§ª Testing customer validation...');
    
    // Test customer data collection
    const customerData = collectCustomerData();
    console.log('ğŸ“‹ Customer data collected:', customerData);
    
    // Test validation logic
    const hasSelectedCustomer = customerData.customerId && customerData.customerId !== '0';
    const hasNewCustomerData = customerData.name.trim() && customerData.phone.trim();
    
    console.log('ğŸ” Validation results:');
    console.log(`  - Has selected customer: ${hasSelectedCustomer ? 'âœ…' : 'âŒ'}`);
    console.log(`  - Has new customer data: ${hasNewCustomerData ? 'âœ…' : 'âŒ'}`);
    console.log(`  - Customer ID: "${customerData.customerId}"`);
    console.log(`  - Customer Name: "${customerData.name}"`);
    console.log(`  - Customer Phone: "${customerData.phone}"`);
    
    const isValid = hasSelectedCustomer || hasNewCustomerData;
    console.log(`ğŸ¯ Overall validation: ${isValid ? 'âœ… PASS' : 'âŒ FAIL'}`);
    
    // Test form fields existence
    const requiredFields = ['customerSelect', 'customerName', 'customerPhone', 'customerAddress'];
    requiredFields.forEach(fieldId => {
        const element = document.getElementById(fieldId);
        console.log(`ğŸ“ Field ${fieldId}: ${element ? 'âœ… Found' : 'âŒ Missing'}`);
        if (element) {
            console.log(`    â””â”€ Value: "${element.value}"`);
        }
    });
    
    return { isValid, customerData, hasSelectedCustomer, hasNewCustomerData };
}

// Export customer test function
window.testCustomerValidation = testCustomerValidation;

// Show customer field requirements
function showCustomerRequirements() {
    console.log('ğŸ“‹ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„:');
    console.log('==================');
    console.log('ğŸ”¹ Ù„Ø¹Ù…ÙŠÙ„ Ù…ÙˆØ¬ÙˆØ¯:');
    console.log('   â””â”€ Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø©');
    console.log('');
    console.log('ğŸ”¹ Ù„Ø¹Ù…ÙŠÙ„ Ø¬Ø¯ÙŠØ¯:');
    console.log('   â”œâ”€ Ø§Ù„Ø§Ø³Ù… (Ù…Ø·Ù„ÙˆØ¨)');
    console.log('   â”œâ”€ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ (Ù…Ø·Ù„ÙˆØ¨)');
    console.log('   â””â”€ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)');
    console.log('');
    console.log('ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§Ù‹ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù…ÙŠÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„Ù‡Ø§ØªÙ');
    
    const testResult = testCustomerValidation();
    return testResult;
}

// Export helper function
window.showCustomerRequirements = showCustomerRequirements;

// Initialize payment validation and features
function initializePaymentValidation() {
    console.log('ğŸ’° Initializing payment validation...');
    
    const amountPaidInput = document.getElementById('amountPaid');
    if (!amountPaidInput) {
        console.warn('âš ï¸ amountPaid input not found');
        return;
    }
    
    // Remove automatic validation - let user enter amount freely
    // amountPaidInput.addEventListener('input', function() {
    //     validatePaymentAmount();
    // });
    
    // Add event listener for amount paid input
    amountPaidInput.addEventListener('input', function() {
        validatePaymentAmount();
    });
    
    // Add event listener for shipping cost
    const shippingCostInput = document.getElementById('shippingCost');
    if (shippingCostInput) {
        shippingCostInput.addEventListener('input', function() {
            updateCartSummary();
            validatePaymentAmount();
        });
    }
    
    // Remove automatic calculation suggestion
    // amountPaidInput.addEventListener('focus', function() {
    //     suggestPaymentAmount();
    // });
    
    console.log('âœ… Payment validation initialized');
}

// Validate payment amount
function validatePaymentAmount() {
    const amountPaidInput = document.getElementById('amountPaid');
    const amountPaid = Math.round(parseFloat(amountPaidInput?.value || 0) * 100) / 100;
    const grandTotal = getCartGrandTotal();
    
    // Remove previous validation classes
    amountPaidInput.classList.remove('is-valid', 'is-invalid');
    
    // Clear previous feedback
    let feedback = amountPaidInput.parentElement.querySelector('.payment-feedback');
    if (feedback) {
        feedback.remove();
    }
    
    if (amountPaid < 0) {
        amountPaidInput.classList.add('is-invalid');
        showPaymentFeedback(amountPaidInput, 'âŒ Ø§Ù„Ù…Ø¨Ù„Øº Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ø³Ø§Ù„Ø¨Ø§Ù‹', 'invalid');
    } else if (amountPaid === 0) {
        amountPaidInput.classList.add('is-invalid');
        showPaymentFeedback(amountPaidInput, 'âš ï¸ Ù…Ø¹Ø§Ù…Ù„Ø© ØºÙŠØ± Ù…Ø¯ÙÙˆØ¹Ø©', 'warning');
    } else if (amountPaid < grandTotal) {
        amountPaidInput.classList.add('is-valid');
        const remaining = grandTotal - amountPaid;
        showPaymentFeedback(amountPaidInput, `ğŸ’° Ù…Ø¯ÙÙˆØ¹ Ø¬Ø²Ø¦ÙŠØ§Ù‹ - Ù…ØªØ¨Ù‚ÙŠ: ${remaining.toFixed(2)} Ø¬.Ù…`, 'partial');
        
        // Update remaining amount display
        updateRemainingAmountDisplay(remaining);
    } else if (amountPaid >= grandTotal) {
        amountPaidInput.classList.add('is-valid');
        if (amountPaid > grandTotal) {
            const change = amountPaid - grandTotal;
            showPaymentFeedback(amountPaidInput, `âœ… Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ - Ø§Ù„Ø¨Ø§Ù‚ÙŠ: ${change.toFixed(2)} Ø¬.Ù…`, 'overpaid');
            
            // Update remaining amount display (negative for change)
            updateRemainingAmountDisplay(-change);
        } else {
            showPaymentFeedback(amountPaidInput, 'âœ… Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„', 'paid');
            
            // Update remaining amount display (zero)
            updateRemainingAmountDisplay(0);
        }
    }
    
    // Also call calculateRemainingAmount for console logging
    calculateRemainingAmount();
}

// Update remaining amount display
function updateRemainingAmountDisplay(remaining) {
    const remainingElement = document.getElementById('remainingAmount');
    if (remainingElement) {
        if (remaining > 0) {
            remainingElement.textContent = `${remaining.toFixed(2)} Ø¬.Ù…`;
            remainingElement.className = 'summary-value warning';
            remainingElement.title = `Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${remaining.toFixed(2)} Ø¬.Ù…`;
        } else if (remaining < 0) {
            remainingElement.textContent = `${Math.abs(remaining).toFixed(2)} Ø¬.Ù…`;
            remainingElement.className = 'summary-value success';
            remainingElement.title = `Ø§Ù„Ø¨Ø§Ù‚ÙŠ: ${Math.abs(remaining).toFixed(2)} Ø¬.Ù…`;
        } else {
            remainingElement.textContent = '0.00 Ø¬.Ù…';
            remainingElement.className = 'summary-value success';
            remainingElement.title = 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„';
        }
        
        console.log(`ğŸ’° ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${remainingElement.textContent}`);
    } else {
        console.warn('âš ï¸ Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }
}

// Show payment feedback
function showPaymentFeedback(input, message, type) {
    const feedback = document.createElement('div');
    feedback.className = `payment-feedback ${type}`;
    feedback.style.cssText = `
        font-size: 12px;
        margin-top: 5px;
        padding: 5px 8px;
        border-radius: 4px;
        font-weight: 500;
    `;
    
    switch(type) {
        case 'invalid':
            feedback.style.background = '#fee';
            feedback.style.color = '#d32f2f';
            feedback.style.border = '1px solid #ffcdd2';
            break;
        case 'warning':
            feedback.style.background = '#fff3e0';
            feedback.style.color = '#f57c00';
            feedback.style.border = '1px solid #ffcc02';
            break;
        case 'partial':
            feedback.style.background = '#e3f2fd';
            feedback.style.color = '#1976d2';
            feedback.style.border = '1px solid #90caf9';
            break;
        case 'paid':
            feedback.style.background = '#e8f5e8';
            feedback.style.color = '#2e7d32';
            feedback.style.border = '1px solid #a5d6a7';
            break;
        case 'overpaid':
            feedback.style.background = '#f3e5f5';
            feedback.style.color = '#7b1fa2';
            feedback.style.border = '1px solid #ce93d8';
            break;
    }
    
    feedback.textContent = message;
    input.parentElement.appendChild(feedback);
}

// Calculate remaining amount (helper function)
function calculateRemainingAmount() {
    const amountPaidInput = document.getElementById('amountPaid');
    const amountPaid = Math.round(parseFloat(amountPaidInput?.value || 0) * 100) / 100;
    const grandTotal = getCartGrandTotal();
    
    const remaining = grandTotal - amountPaid;
    
    console.log('ğŸ’° Remaining Amount Calculation:', {
        grandTotal: grandTotal.toFixed(2),
        amountPaid: amountPaid.toFixed(2),
        remaining: remaining.toFixed(2)
    });
    
    const result = {
        grandTotal,
        amountPaid,
        remaining,
        isPaid: amountPaid >= grandTotal,
        isOverpaid: amountPaid > grandTotal,
        change: amountPaid > grandTotal ? amountPaid - grandTotal : 0
    };
    
    // Show result to user
    if (result.isOverpaid) {
        showMessage(`ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${result.grandTotal.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${result.amountPaid.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ø¨Ø§Ù‚ÙŠ: ${result.change.toFixed(2)} Ø¬.Ù…`, 'success');
    } else if (result.isPaid) {
        showMessage(`âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${result.grandTotal.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${result.amountPaid.toFixed(2)} Ø¬.Ù… | ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„`, 'success');
    } else {
        showMessage(`ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${result.grandTotal.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${result.amountPaid.toFixed(2)} Ø¬.Ù… | Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${result.remaining.toFixed(2)} Ø¬.Ù…`, 'info');
    }
    
    return result;
}

// Suggest payment amount based on cart total (optional)
function suggestPaymentAmount() {
    const amountPaidInput = document.getElementById('amountPaid');
    const grandTotal = getCartGrandTotal();
    
    if (!amountPaidInput.value && grandTotal > 0) {
        const suggest = confirm(`ğŸ’¡ Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹ Ø¥Ù„Ù‰ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø© (${grandTotal.toFixed(2)} Ø¬.Ù…)ØŸ`);
        if (suggest) {
            amountPaidInput.value = grandTotal.toFixed(2);
            // Don't auto-validate, just show the calculation
            const calc = calculateRemainingAmount();
            showMessage(`ğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${calc.amountPaid.toFixed(2)} Ø¬.Ù… - Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${calc.remaining.toFixed(2)} Ø¬.Ù…`, 'info');
        }
    }
}

// Get cart grand total
function getCartGrandTotal() {
    if (!cart || cart.length === 0) return 0;
    
    let totalAmount = 0;
    let totalDiscount = 0;
    
    cart.forEach(item => {
        const itemSubTotal = item.price * item.quantity; // Don't use Math.abs here
        const itemTotal = item.total || itemSubTotal;
        const discountAmount = item.discount || 0; // Direct amount
        
        if (item.quantity < 0) {
            // Return item - add negative value, but don't add discount
            totalAmount += itemSubTotal; 
            // totalDiscount += discountAmount; // Ù„Ø§ Ù†Ø­Ø³Ø¨ Ø§Ù„Ø®ØµÙ… ÙÙŠ Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹
        } else {
            // Sale item - add positive value and discount
            totalAmount += itemSubTotal; 
            totalDiscount += discountAmount;
        }
    });
    
    // Get shipping cost
    const shippingCostInput = document.getElementById('shippingCost');
    const shippingCost = parseFloat(shippingCostInput?.value || 0);
    
    const finalTotal = totalAmount - totalDiscount + shippingCost;
    
    // Log calculation for debugging
    console.log('ğŸ’° Cart Grand Total Calculation:', {
        totalAmount: totalAmount.toFixed(2),
        totalDiscount: totalDiscount.toFixed(2),
        shippingCost: shippingCost.toFixed(2),
        finalTotal: finalTotal.toFixed(2),
        items: cart.map(item => ({
            name: item.name,
            quantity: item.quantity,
            subtotal: (Math.abs(item.price * item.quantity)).toFixed(2),
            discount: (item.discount || 0).toFixed(2),
            total: Math.abs(item.total || (item.price * item.quantity)).toFixed(2),
            mode: item.quantity < 0 ? 'return' : 'sale'
        }))
    });
    
    return finalTotal;
}

// Test payment functionality
function testPaymentSystem() {
    console.log('ğŸ§ª Testing payment system...');
    
    const amountPaidInput = document.getElementById('amountPaid');
    const grandTotal = getCartGrandTotal();
    
    console.log('ğŸ“Š Current state:');
    console.log(`  - Cart grand total: ${grandTotal.toFixed(2)} Ø¬.Ù…`);
    console.log(`  - Amount paid input: ${amountPaidInput ? 'âœ… Found' : 'âŒ Missing'}`);
    
    if (amountPaidInput) {
        console.log(`  - Current paid amount: ${amountPaidInput.value || '0'} Ø¬.Ù…`);
        
        // Test different payment scenarios
        const testCases = [
            { amount: 0, desc: 'ØºÙŠØ± Ù…Ø¯ÙÙˆØ¹' },
            { amount: grandTotal * 0.5, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø¬Ø²Ø¦ÙŠØ§Ù‹' },
            { amount: grandTotal, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„' },
            { amount: grandTotal * 1.2, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø²Ø§Ø¦Ø¯' }
        ];
        
        console.log('ğŸ” Testing payment scenarios:');
        testCases.forEach((testCase, index) => {
            console.log(`  ${index + 1}. ${testCase.desc}: ${testCase.amount.toFixed(2)} Ø¬.Ù…`);
        });
        
        console.log('ğŸ’¡ Use: amountPaidInput.value = "100"; validatePaymentAmount(); to test');
        
        // Auto-test payment scenarios
        console.log('ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹...');
        testCases.forEach((testCase, index) => {
            setTimeout(() => {
                console.log(`ğŸ’³ Ø§Ø®ØªØ¨Ø§Ø± ${index + 1}: ${testCase.desc} - ${testCase.amount.toFixed(2)} Ø¬.Ù…`);
                amountPaidInput.value = testCase.amount.toFixed(2);
                validatePaymentAmount();
            }, (index + 1) * 3000);
        });
    }
    
    return { grandTotal, amountPaidInput, hasCart: cart.length > 0 };
}

// Export payment test function
window.testPaymentSystem = testPaymentSystem;

// Quick test for payment amount
function testPaymentAmount(amount) {
    console.log(`ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${amount} Ø¬.Ù…`);
    
    const amountPaidInput = document.getElementById('amountPaid');
    if (amountPaidInput) {
        amountPaidInput.value = amount;
        validatePaymentAmount();
        
        const grandTotal = getCartGrandTotal();
        const remaining = grandTotal - parseFloat(amount);
        
        console.log('ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬:');
        console.log(`  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${grandTotal.toFixed(2)} Ø¬.Ù…`);
        console.log(`  - Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹: ${amount} Ø¬.Ù…`);
        console.log(`  - Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${remaining.toFixed(2)} Ø¬.Ù…`);
        
        if (remaining > 0) {
            console.log(`  - Ø§Ù„Ø­Ø§Ù„Ø©: Ù…Ø¯ÙÙˆØ¹ Ø¬Ø²Ø¦ÙŠØ§Ù‹ - Ù…ØªØ¨Ù‚ÙŠ ${remaining.toFixed(2)} Ø¬.Ù…`);
        } else if (remaining < 0) {
            console.log(`  - Ø§Ù„Ø­Ø§Ù„Ø©: Ù…Ø¯ÙÙˆØ¹ Ø²Ø§Ø¦Ø¯ - Ø¨Ø§Ù‚ÙŠ ${Math.abs(remaining).toFixed(2)} Ø¬.Ù…`);
        } else {
            console.log(`  - Ø§Ù„Ø­Ø§Ù„Ø©: Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„`);
        }
    } else {
        console.error('âŒ Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }
}



// Get invoice status badge HTML
function getInvoiceStatusBadge(status) {
    const statusMap = {
        'Draft': { text: 'ÙÙŠ Ø§Ù„Ù…ÙƒØªØ¨', class: 'bg-secondary' },
        'Sent': { text: 'ØºÙŠØ± Ù…Ø¯ÙÙˆØ¹', class: 'bg-warning' },
        'Paid': { text: 'Ù…Ø¯ÙÙˆØ¹', class: 'bg-success' },
        'PartiallyPaid': { text: 'Ù…Ø¯ÙÙˆØ¹ Ø¬Ø²Ø¦ÙŠØ§Ù‹', class: 'bg-info' },
        'Overdue': { text: 'Ù…ØªØ£Ø®Ø±', class: 'bg-danger' },
        'Cancelled': { text: 'Ù…Ù„ØºÙŠ', class: 'bg-dark' }
    };
    
    const statusInfo = statusMap[status] || statusMap['Paid'];
    return `<span class="badge ${statusInfo.class}">${statusInfo.text}</span>`;
}











// Create camelCase version of transaction data
function prepareTransactionDataCamelCase(customerData) {
    console.log('ğŸ”§ Preparing camelCase transaction data...');
    
    if (!cart || cart.length === 0) {
        console.error('âŒ Cart is empty!');
        return null;
    }
    
    let subTotal = 0;
    let totalDiscount = 0;
    
    const items = cart.map(item => {
        const itemSubTotal = Math.abs(item.price * item.quantity);
        const itemDiscount = item.discount || 0; // Direct amount, not percentage
        const itemTotal = itemSubTotal - itemDiscount;
        
        subTotal += (item.quantity < 0 ? -itemSubTotal : itemSubTotal); // Use subtotal for calculation
        // Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹: Ù„Ø§ Ù†Ø±Ø³Ù„ Ø§Ù„Ø®ØµÙ… (Ø§Ù„Ø®ØµÙ… Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø§ ÙŠÙØ¹ØªØ¨Ø± Ø®Ø³Ø§Ø±Ø©)
        totalDiscount += (item.quantity < 0 ? 0 : itemDiscount);
        
        return {
            productId: item.productId || item.id,
            productName: item.name,
            quantity: item.quantity,
            price: item.price,
            discount: item.quantity < 0 ? 0 : (item.discount || 0), // Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹: Ù„Ø§ Ø®ØµÙ…
            notes: item.notes || null
        };
    });
    
    // Get fields
    const policyNumber = document.getElementById('policyNumber')?.value || '';
            const orderOrigin = document.getElementById('orderOrigin')?.value || 7;
    const paymentMethod = document.getElementById('paymentMethod')?.value || '';
    const shippingCost = parseFloat(document.getElementById('shippingCost')?.value || 0);
    const invoiceNumber = document.getElementById('invoiceNumber')?.value || '';
    const originalInvoiceNumber = document.getElementById('originalInvoiceNumber')?.value || '';
    const returnNotes = document.getElementById('returnNotes')?.value || '';
    const amountPaidInput = document.getElementById('amountPaid');
    const amountPaid = Math.round(parseFloat(amountPaidInput?.value || 0) * 100) / 100;
    const invoiceType = subTotal < 0 ? 2 : 1;
    
    return {
        customerId: parseInt(customerData.customerId) || 0,
        customerName: customerData.name || '',
        customerPhone: customerData.phone || '',
        customerAddress: customerData.address || '',
        items: items,
        amountPaid: amountPaid,
        invoiceNumber: invoiceNumber,
        policyNumber: policyNumber,
                    orderOrigin: parseInt(orderOrigin) || 7,
        paymentMethod: paymentMethod,
        shippingCost: subTotal >= 0 ? shippingCost : 0,
        invoiceType: invoiceType,
        originalInvoiceNumber: originalInvoiceNumber,
        notes: returnNotes
    };
}





// Animate field fill effect
function animateFieldFill(field) {
    if (!field) return;
    
    field.classList.add('filled');
    setTimeout(() => {
        field.classList.remove('filled');
    }, 400);
}

// Update process button state based on cart contents
function updateProcessButtonState() {
    try {
        const processButton = document.getElementById('processTransactionBtn');
        if (!processButton) {
            console.warn('âš ï¸ Process button not found');
            return;
        }
        
        const hasItems = cart && cart.length > 0;
        const hasValidItems = hasItems && cart.some(item => item.quantity !== 0);
        
        if (hasValidItems) {
            processButton.disabled = false;
            processButton.classList.remove('btn-secondary');
            processButton.classList.add('btn-success');
            
            const totalItems = cart.reduce((sum, item) => sum + Math.abs(item.quantity), 0);
            const buttonText = isReturnMode ? 
                `ğŸ’° Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹ (${totalItems} Ù‚Ø·Ø¹Ø©)` : 
                `ğŸ’° Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© (${totalItems} Ù‚Ø·Ø¹Ø©)`;
            processButton.textContent = buttonText;
            
            console.log('âœ… Process button enabled:', buttonText);
        } else {
            processButton.disabled = true;
            processButton.classList.remove('btn-success');
            processButton.classList.add('btn-secondary');
            processButton.textContent = 'ğŸ’° Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©';
            
            console.log('âš ï¸ Process button disabled - no valid items');
        }
    } catch (error) {
        console.error('âŒ Error updating process button state:', error);
    }
}

// Print invoice (placeholder)
function printInvoice(invoiceId) {
    console.log('ğŸ–¨ï¸ Printing invoice:', invoiceId);
    
    // Navigate to invoice page instead of opening new tab
    const printUrl = `/Invoices/ModernInvoice/${invoiceId}`;
    window.location.href = printUrl;
}

// ===============================================
// Utility Functions
// ===============================================

// Show message to user (utility function)
const DEBUG = false;

function showMessage(message, type = 'info', duration = 5000) {
    if (DEBUG) console.log(`Message (${type}): ${message}`);
    
    // Create toast container if it doesn't exist
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    // Set icon based on type
    const typeEmojis = {
        'info': 'â„¹ï¸',
        'success': 'âœ…',
        'warning': 'âš ï¸',
        'error': 'âŒ'
    };
    
    const icon = typeEmojis[type] || 'â„¹ï¸';
    
    toast.innerHTML = `
        <div class="toast-content">
            <span class="toast-icon">${icon}</span>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="closeToast(this)">&times;</button>
        </div>
    `;
    
    // Add to container
    toastContainer.appendChild(toast);
    
    // Show toast with animation
    setTimeout(() => {
        toast.classList.add('toast-show');
    }, 10);
    
    // Auto-hide after specified duration (longer for errors)
    const hideDuration = type === 'error' ? 8000 : duration;
    setTimeout(() => {
        hideToast(toast);
    }, hideDuration);
    
    // Also show alert for critical errors
    if (type === 'error') {
        alert(message);
    }
}

// Hide toast
function hideToast(toast) {
    if (toast && toast.parentNode) {
        toast.classList.remove('toast-show');
        toast.classList.add('toast-hide');
        
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 300);
    }
}

// Close toast manually
function closeToast(button) {
    const toast = button.closest('.toast');
    hideToast(toast);
}

// Log system information
function logSystemInfo() {
    console.log('=== Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Screen Size:', `${screen.width}x${screen.height}`);
    console.log('Viewport Size:', `${window.innerWidth}x${window.innerHeight}`);
    console.log('Current URL:', window.location.href);
    console.log('Document Ready State:', document.readyState);
    console.log('=====================================');
}

// ===============================================
// Initialization
// ===============================================

// Initialize the cashier system
async function initializeCashierSystem() {
    console.log('ğŸš€ ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ø´ÙŠØ±...');
    
    // Log system information
    logSystemInfo();
    
    // Test essential elements (updated for new system)
    const essentialElements = [
        'processTransactionBtn',
        'clearCartBtn',
    ];
    
    let missingElements = [];
    essentialElements.forEach(id => {
        const element = document.getElementById(id);
        if (!element) {
            missingElements.push(id);
        }
    });
    
    if (missingElements.length > 0) {
        console.warn('Ø¹Ù†Ø§ØµØ± Ù…ÙÙ‚ÙˆØ¯Ø©:', missingElements);
    } else {
        console.log('âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }
    
    // Test essential functions (updated for new system)
    const essentialFunctions = [
        'testJS',
        'clearCart',
        'processTransaction',
        'addProductToCart'
    ];
    
    console.log('=== ÙØ­Øµ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===');
    essentialFunctions.forEach(funcName => {
        const funcType = typeof window[funcName];
        console.log(`${funcName}: ${funcType}`);
    });
    
    console.log('âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­');
    console.log('Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ:', new Date().toLocaleString());
    
    // Initialize customer form validation
    initializeCustomerValidation();
    
    // Initialize cart state
    updateProcessButtonState();
    updateCartSummary();
    
    // Initialize payment validation
    initializePaymentValidation();
    
    // Initialize mode-specific features
    initializeModeFeatures();
    
    // Initialize order origin change listener
    initializeOrderOriginListener();
    
    // Note: Automatic number generation has been removed as requested
}

// Initialize order origin change listener
function initializeOrderOriginListener() {
    const orderOriginSelect = document.getElementById('orderOrigin');
    if (orderOriginSelect) {
        orderOriginSelect.addEventListener('change', function() {
            const selectedValue = this.value;
            const selectedText = this.options[this.selectedIndex].text;
            console.log(`ğŸª Order origin changed to: ${selectedText} (${selectedValue})`);
            
            // Update payment method field visibility based on selection
            const paymentMethodField = document.getElementById('paymentMethod');
            if (paymentMethodField) {
                const onlineOrigins = ['1', '2', '3', '4']; // Website, Instagram, Facebook, WhatsApp
                if (onlineOrigins.includes(selectedValue)) {
                    paymentMethodField.required = true;
                    paymentMethodField.style.borderColor = '#dc3545';
                } else {
                    paymentMethodField.required = false;
                    paymentMethodField.style.borderColor = '';
                }
            }
            
            // Show success message
            showMessage(`ØªÙ… ØªØºÙŠÙŠØ± Ù…ØµØ¯Ø± Ø§Ù„Ø·Ù„Ø¨ Ø¥Ù„Ù‰: ${selectedText}`, 'success');
        });
        
        console.log('âœ… Order origin change listener initialized');
    } else {
        console.warn('âš ï¸ Order origin select not found');
    }
}

// Run initialization when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => initializeCashierSystem());
} else {
    // DOM is already loaded
    initializeCashierSystem();
}

// Also run on window load as backup
window.addEventListener('load', function() {
    console.log('âœ… Window loaded - Cashier system ready');
});

// ===============================================
// Enhanced Customer Management Functions
// ===============================================

// Add event listeners for customer search
document.addEventListener('DOMContentLoaded', function() {
    // Add Enter key support for phone search
    const phoneSearchInput = document.getElementById('customerPhone');
    if (phoneSearchInput) {
        phoneSearchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchCustomerByPhone();
            }
        });
        
        // Add auto-search when phone number is complete (11 digits)
        phoneSearchInput.addEventListener('input', function(e) {
            const phone = e.target.value.trim();
            if (phone.length === 11 && /^[0-9]{11}$/.test(phone)) {
                // Auto-search after a short delay
                setTimeout(() => {
                    searchCustomerByPhone();
                }, 500);
            }
        });
    }
    
    console.log('âœ… Customer search event listeners added');
});

// Handle customer selection from dropdown
function handleCustomerSelection() {
    const select = document.getElementById('customerSelect');
    const selectedOption = select.options[select.selectedIndex];
    
    console.log('ğŸ‘¤ Customer selection changed:', selectedOption.value);
    
    if (selectedOption.value) {
        // Fill customer data from selected option
        fillCustomerDataFromOption(selectedOption);
        
        const customerName = selectedOption.getAttribute('data-name');
        updateCustomerStatus(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù…ÙŠÙ„: ${customerName}`, 'success');
        animateCustomerFilled();
        
        // Show success message
        showMessage(`ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù…ÙŠÙ„: ${customerName}`, 'success');
        
        console.log(`âœ… Customer selected: ${customerName}`);
    } else {
        clearCustomerData();
        updateCustomerStatus('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¹Ù…ÙŠÙ„', 'info');
        console.log('ğŸ”„ Customer selection cleared');
    }
}

// Fill customer data from search results
function fillCustomerDataFromSearch(customer) {
    try {
        console.log('ğŸ”„ Filling customer data from search...');
        
        // Fill name
        const nameField = document.getElementById('customerName');
        if (nameField) {
            nameField.value = customer.name || '';
            animateFieldFill(nameField);
            console.log(`âœ… Name filled: ${nameField.value}`);
        }
        
        // Fill phone numbers (both fields) without formatting
        const phoneValue = customer.phone || '';
        const phoneField = document.getElementById('customerPhone');
        const phoneInputField = document.getElementById('customerPhoneInput');
        
        if (phoneField) {
            phoneField.value = phoneValue;
            animateFieldFill(phoneField);
            console.log(`âœ… Phone field filled: ${phoneField.value}`);
        }
        if (phoneInputField) {
            phoneInputField.value = phoneValue;
            animateFieldFill(phoneInputField);
            console.log(`âœ… Phone input field filled: ${phoneInputField.value}`);
        }
        
        // Fill additional phone without formatting
        const additionalPhoneField = document.getElementById('customerAdditionalPhone');
        if (additionalPhoneField) {
            additionalPhoneField.value = customer.additionalPhone || '';
            animateFieldFill(additionalPhoneField);
            console.log(`âœ… Additional phone filled: ${additionalPhoneField.value}`);
        }
        
        // Fill email
        const emailField = document.getElementById('customerEmail');
        if (emailField) {
            emailField.value = customer.email || '';
            animateFieldFill(emailField);
            console.log(`âœ… Email filled: ${emailField.value}`);
        }
        
        // Fill governorate
        const governorateField = document.getElementById('customerGovernorate');
        if (governorateField) {
            governorateField.value = customer.governorate || '';
            animateFieldFill(governorateField);
            console.log(`âœ… Governorate filled: ${governorateField.value}`);
        }
        
        // Fill district
        const districtField = document.getElementById('customerDistrict');
        if (districtField) {
            districtField.value = customer.district || '';
            animateFieldFill(districtField);
            console.log(`âœ… District filled: ${districtField.value}`);
        }
        
        // Fill detailed address
        const detailedAddressField = document.getElementById('customerDetailedAddress');
        if (detailedAddressField) {
            detailedAddressField.value = customer.detailedAddress || '';
            animateFieldFill(detailedAddressField);
            console.log(`âœ… Detailed address filled: ${detailedAddressField.value}`);
        }
        
        console.log('âœ… All customer fields filled successfully');
        
    } catch (error) {
        console.error('âŒ Error filling customer data from search:', error);
    }
}

// Update customer select dropdown to show selected customer
function updateCustomerSelect(customer) {
    try {
        const select = document.getElementById('customerSelect');
        if (!select) {
            console.warn('Customer select dropdown not found');
            return;
        }
        
        // Find and select the customer in the dropdown
        for (let i = 0; i < select.options.length; i++) {
            const option = select.options[i];
            if (option.value == customer.id) {
                select.selectedIndex = i;
                console.log(`âœ… Customer select updated to: ${customer.name}`);
                return;
            }
        }
        
        // If customer not found in dropdown, add it temporarily
        const newOption = document.createElement('option');
        newOption.value = customer.id;
        newOption.text = `${customer.name} - ${customer.phone}`;
        newOption.setAttribute('data-name', customer.name);
        newOption.setAttribute('data-phone', customer.phone);
        newOption.setAttribute('data-additional-phone', customer.additionalPhone || '');
        newOption.setAttribute('data-email', customer.email || '');
        newOption.setAttribute('data-governorate', customer.governorate || '');
        newOption.setAttribute('data-district', customer.district || '');
        newOption.setAttribute('data-detailed-address', customer.detailedAddress || '');
        
        select.add(newOption);
        select.selectedIndex = select.options.length - 1;
        
        console.log(`âœ… Customer added to dropdown: ${customer.name}`);
        
    } catch (error) {
        console.error('âŒ Error updating customer select:', error);
    }
}

// Fill customer data from dropdown option
function fillCustomerDataFromOption(option) {
    try {
        console.log('ğŸ”„ Filling customer data from selection...');
        
        // Fill name
        const nameField = document.getElementById('customerName');
        if (nameField) {
            nameField.value = option.getAttribute('data-name') || '';
            animateFieldFill(nameField);
            console.log(`âœ… Name filled: ${nameField.value}`);
        }
        
        // Fill phone numbers (both fields) without formatting
        const phoneValue = option.getAttribute('data-phone') || '';
        const phoneField = document.getElementById('customerPhone');
        const phoneInputField = document.getElementById('customerPhoneInput');
        
        if (phoneField) {
            phoneField.value = phoneValue;
            animateFieldFill(phoneField);
            console.log(`âœ… Phone field filled: ${phoneField.value}`);
        }
        if (phoneInputField) {
            phoneInputField.value = phoneValue;
            animateFieldFill(phoneInputField);
            console.log(`âœ… Phone input field filled: ${phoneInputField.value}`);
        }
        
        // Fill additional phone without formatting
        const additionalPhoneField = document.getElementById('customerAdditionalPhone');
        if (additionalPhoneField) {
            additionalPhoneField.value = option.getAttribute('data-additional-phone') || '';
            animateFieldFill(additionalPhoneField);
            console.log(`âœ… Additional phone filled: ${additionalPhoneField.value}`);
        }
        
        // Fill email
        const emailField = document.getElementById('customerEmail');
        if (emailField) {
            emailField.value = option.getAttribute('data-email') || '';
            animateFieldFill(emailField);
            console.log(`âœ… Email filled: ${emailField.value}`);
        }
        
        // Fill governorate
        const governorateField = document.getElementById('customerGovernorate');
        if (governorateField) {
            governorateField.value = option.getAttribute('data-governorate') || '';
            animateFieldFill(governorateField);
            console.log(`âœ… Governorate filled: ${governorateField.value}`);
        }
        
        // Fill district
        const districtField = document.getElementById('customerDistrict');
        if (districtField) {
            districtField.value = option.getAttribute('data-district') || '';
            animateFieldFill(districtField);
            console.log(`âœ… District filled: ${districtField.value}`);
        }
        
        // Fill detailed address
        const detailedAddressField = document.getElementById('customerDetailedAddress');
        if (detailedAddressField) {
            detailedAddressField.value = option.getAttribute('data-detailed-address') || '';
            animateFieldFill(detailedAddressField);
            console.log(`âœ… Detailed address filled: ${detailedAddressField.value}`);
        }
        
        // Fill backward compatibility address field if exists
        const addressField = document.getElementById('customerAddress');
        if (addressField) {
            const fullAddress = [
                option.getAttribute('data-governorate'),
                option.getAttribute('data-district'),
                option.getAttribute('data-detailed-address')
            ].filter(Boolean).join(', ');
            addressField.value = fullAddress;
            animateFieldFill(addressField);
            console.log(`âœ… Address field filled: ${fullAddress}`);
        }
        
        console.log('âœ… Customer data filled successfully');
        
        // Validate form after filling
        if (typeof validateCustomerForm === 'function') {
        validateCustomerForm();
        }
        
    } catch (error) {
        console.error('âŒ Error filling customer data:', error);
        showMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¨Ø¦Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„', 'error');
    }
}

// Clear all customer data
function clearCustomerData() {
    const customerFields = [
        'customerSelect',
        'customerName',
        'customerPhoneInput', 
        'customerAdditionalPhone',
        'customerEmail',
        'customerGovernorate',
        'customerDistrict',
        'customerDetailedAddress',
        'customerPhone'
    ];
    
    customerFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
            field.value = '';
            field.classList.remove('is-valid', 'is-invalid');
        }
    });
    
    updateCustomerStatus('ØªÙ… Ù…Ø³Ø­ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„', 'info');
    console.log('Customer data cleared');
}

// Update customer status indicator
function updateCustomerStatus(message, type = 'info') {
    const statusElement = document.getElementById('customerStatusIndicator');
    const statusText = document.getElementById('customerStatusText');
    
    if (statusElement && statusText) {
        // Remove existing status classes
        statusElement.className = 'status-indicator';
        
        // Add new status class
        statusElement.classList.add(type);
        
        // Update text
        statusText.textContent = message;
        
        // Update icon based on type
        const icon = statusElement.querySelector('i');
        if (icon) {
            icon.className = getStatusIcon(type);
        }
    }
}

// Get icon class based on status type
function getStatusIcon(type) {
    const icons = {
        'info': 'fas fa-info-circle me-1',
        'success': 'fas fa-check-circle me-1',
        'warning': 'fas fa-exclamation-triangle me-1',
        'error': 'fas fa-times-circle me-1'
    };
    
    return icons[type] || icons['info'];
}

// Animate customer section when data is filled
function animateCustomerFilled() {
    const customerSection = document.querySelector('.cashier-card-body');
    if (customerSection) {
        customerSection.classList.add('customer-info-filled');
        setTimeout(() => {
            customerSection.classList.remove('customer-info-filled');
        }, 500);
    }
}

// Validate customer form
function validateCustomerForm() {
    const nameField = document.getElementById('customerName');
    const phoneField = document.getElementById('customerPhoneInput');
    const emailField = document.getElementById('customerEmail');
    const additionalPhoneField = document.getElementById('customerAdditionalPhone');
    
    let isValid = true;
    
    // Validate name
    if (nameField && nameField.value.trim().length >= 2) {
        nameField.classList.remove('is-invalid');
        nameField.classList.add('is-valid');
    } else if (nameField && nameField.value.trim().length > 0) {
        nameField.classList.remove('is-valid');
        nameField.classList.add('is-invalid');
        isValid = false;
    }
    
    // Validate main phone
    if (phoneField && /^[0-9]{11}$/.test(phoneField.value.trim())) {
        phoneField.classList.remove('is-invalid');
        phoneField.classList.add('is-valid');
    } else if (phoneField && phoneField.value.trim().length > 0) {
        phoneField.classList.remove('is-valid');
        phoneField.classList.add('is-invalid');
        isValid = false;
    }
    
    // Validate email (optional)
    if (emailField && emailField.value.trim()) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (emailRegex.test(emailField.value.trim())) {
            emailField.classList.remove('is-invalid');
            emailField.classList.add('is-valid');
        } else {
            emailField.classList.remove('is-valid');
            emailField.classList.add('is-invalid');
            isValid = false;
        }
    }
    
    // Validate additional phone (optional)
    if (additionalPhoneField && additionalPhoneField.value.trim()) {
        if (/^[0-9]{11}$/.test(additionalPhoneField.value.trim())) {
            additionalPhoneField.classList.remove('is-invalid');
            additionalPhoneField.classList.add('is-valid');
        } else {
            additionalPhoneField.classList.remove('is-valid');
            additionalPhoneField.classList.add('is-invalid');
            isValid = false;
        }
    }
    
    // Update status based on validation
    if (isValid && nameField?.value.trim() && phoneField?.value.trim()) {
        updateCustomerStatus('âœ… Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„ ØµØ­ÙŠØ­Ø©', 'success');
    } else if (nameField?.value.trim() || phoneField?.value.trim()) {
        updateCustomerStatus('âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙƒÙ…Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©', 'warning');
    }
    
    return isValid;
}

// Enhanced search customer by phone with validation
function enhancedSearchCustomerByPhone() {
    const phoneInput = document.getElementById('customerPhone');
    const phone = phoneInput?.value?.trim();
    
    if (!phone) {
        showMessage('âŒ Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ', 'warning');
        phoneInput?.focus();
        return;
    }
    
    // Validate phone number format
    if (!/^[0-9]{11}$/.test(phone)) {
        showMessage('âŒ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 11 Ø±Ù‚Ù…Ø§Ù‹', 'warning');
        phoneInput?.focus();
        return;
    }
    
    updateCustomerStatus('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„...', 'info');
    
    // Simulate search (replace with actual AJAX call)
    setTimeout(() => {
        // For now, show search result
        updateCustomerStatus(`ØªÙ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: ${phone} - Ø§Ù„ÙˆØ¸ÙŠÙØ© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±`, 'warning');
        showMessage(`ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„: ${phone} - Ù‚Ø±ÙŠØ¨Ø§Ù‹!`, 'info');
        
        // Clear search input
        phoneInput.value = '';
    }, 1000);
}

// ===============================================
// Enhanced Invoice Search Functions
// ===============================================

// Enhanced search for original invoice
function searchOriginalInvoice() {
    console.log('ğŸ” Starting invoice search...');
    
    const invoiceInput = document.getElementById('originalInvoiceNumber');
    const searchResult = document.getElementById('invoiceSearchResult');
    
    if (!invoiceInput || !searchResult) {
        console.error('âŒ Required elements not found');
        showMessage('Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ø­Ø« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©', 'error');
        return;
    }
    
    const invoiceNumber = invoiceInput.value.trim();
    
    if (!invoiceNumber) {
        showMessage('âš ï¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©', 'warning');
        invoiceInput.focus();
        return;
    }
    
    // Validate invoice number format
    if (invoiceNumber.length < 3) {
        showMessage('âš ï¸ Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹', 'warning');
        invoiceInput.focus();
        return;
    }
    
    // Show loading state
    searchResult.style.display = 'block';
    searchResult.innerHTML = createLoadingIndicator('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙØ§ØªÙˆØ±Ø©...');
    
    // Real API call to search for invoice
    fetch(`/Cashier/SearchInvoices?invoiceNumber=${encodeURIComponent(invoiceNumber)}`)
        .then(response => response.json())
        .then(data => {
            console.log('ğŸ” Invoice search response:', data);
            
            if (data.success && data.invoices && data.invoices.length > 0) {
                // Display the first invoice found (or you could display all)
                const firstInvoice = data.invoices[0];
                displayInvoiceFound(firstInvoice);
                showMessage(`âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${data.invoices.length} ÙØ§ØªÙˆØ±Ø©`, 'success');
            } else {
                // Display appropriate message based on the error
                        displayInvoiceNotFound(invoiceNumber, []);
                const message = data.message || `âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${invoiceNumber}`;
                
                // Show different message if it's about no returnable items
                if (message.includes('Ù…Ù†ØªØ¬Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹')) {
                    showMessage('â„¹ï¸ ØªÙ… Ø¥Ø±Ø¬Ø§Ø¹ Ø¬Ù…ÙŠØ¹ Ù…Ù†ØªØ¬Ø§Øª Ù‡Ø°Ù‡ Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹', 'info');
                } else {
                    showMessage(message, 'error');
                }
            }
        })
        .catch(error => {
            console.error('âŒ Error searching invoice:', error);
            searchResult.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle fa-2x text-danger me-3"></i>
                    <div>
                        <h6 class="mb-1">âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„</h6>
                        <small class="text-muted">Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…: ${error.message}</small>
                    </div>
                </div>
            `;
            showMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙØ§ØªÙˆØ±Ø©', 'error');
        });
}

// Show all available invoices
function showAllInvoices() {
    console.log('ğŸ“‹ Showing all invoices...');
    
    const searchResult = document.getElementById('invoiceSearchResult');
    if (!searchResult) {
        console.error('âŒ Search result element not found');
        return;
    }
    
    // Show loading state
    searchResult.style.display = 'block';
    searchResult.innerHTML = createLoadingIndicator('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙˆØ§ØªÙŠØ±...');
    
    // Real API call to get all invoices
    fetch('/Cashier/GetAllInvoices')
        .then(response => response.json())
        .then(data => {
            console.log('ğŸ“‹ All invoices response:', data);
            
            if (data.success && data.invoices) {
                displayAllInvoices(data.invoices);
                showMessage(`âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ ${data.invoices.length} ÙØ§ØªÙˆØ±Ø©`, 'success');
            } else {
                displayNoInvoicesFound();
                showMessage('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙÙˆØ§ØªÙŠØ± ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…', 'error');
            }
        })
        .catch(error => {
            console.error('âŒ Error fetching invoices:', error);
            searchResult.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle fa-2x text-danger me-3"></i>
                    <div>
                        <h6 class="mb-1">âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„</h6>
                        <small class="text-muted">Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ§ØªÙŠØ±: ${error.message}</small>
                    </div>
                </div>
            `;
            showMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ§ØªÙŠØ±', 'error');
        });
}

// Mock invoices removed - now using real data from API

// Create loading indicator HTML
function createLoadingIndicator(message) {
    return `
        <div class="text-center p-4">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="text-muted">
                <i class="fas fa-search me-2"></i>
                ${message}
            </div>
        </div>
    `;
}

// Display found invoice
function displayInvoiceFound(invoice) {
    const searchResult = document.getElementById('invoiceSearchResult');
    
    const itemsHtml = (invoice.items || []).map(item => `
        <tr>
            <td><strong>${item.productName || item.name}</strong></td>
            <td class="text-center">
                <span class="badge bg-secondary">${item.originalQuantity || item.quantity}</span>
                ${item.returnedQuantity ? `<br><small class="text-muted">Ù…Ø±ØªØ¬Ø¹: ${item.returnedQuantity}</small>` : ''}
            </td>
            <td class="text-center">
                <span class="badge bg-success">${item.availableForReturn || item.quantity}</span>
                <br><small class="text-muted">Ù…ØªØ§Ø­ Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹</small>
            </td>
            <td class="text-end">${(item.unitPrice || item.price || 0).toFixed(2)} Ø¬.Ù…</td>
            <td class="text-center">
                <button class="btn btn-sm btn-outline-primary add-to-return-btn" 
                        onclick="handleReturnItemAdd(this)" 
                        data-product-id="${item.productId}" 
                        data-product-name="${escapeHtml(item.productName || item.name || '')}" 
                        data-quantity="${item.availableForReturn || item.quantity}" 
                        data-price="${item.unitPrice || item.price || 0}">
                    <i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹
                </button>
            </td>
        </tr>
    `).join('');
    
    searchResult.innerHTML = `
        <div class="alert alert-success">
            <div class="d-flex align-items-center mb-3">
                <i class="fas fa-check-circle fa-2x text-success me-3"></i>
                <div>
                    <h6 class="mb-1">âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ÙØ§ØªÙˆØ±Ø©</h6>
                    <small class="text-muted">Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ù…ØªØ§Ø­Ø© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹/Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„</small>
                </div>
            </div>
            
            <div class="row">
                <div class="col-md-6">
                    <strong>Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©:</strong> ${invoice.invoiceNumber || invoice.number}<br>
                    <strong>Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„:</strong> ${invoice.customerName || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}<br>
                    <strong>Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ:</strong> ${invoice.customerPhone || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
                </div>
                <div class="col-md-6">
                    <strong>Ø§Ù„ØªØ§Ø±ÙŠØ®:</strong> ${new Date(invoice.invoiceDate || invoice.date).toLocaleDateString('ar-EG')}<br>
                    <strong>Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:</strong> ${(invoice.totalAmount || invoice.total || 0).toFixed(2)} Ø¬.Ù…<br>
                    <strong>Ø§Ù„Ø­Ø§Ù„Ø©:</strong> ${getInvoiceStatusBadge(invoice.status || 'Paid')}
                </div>
            </div>
            
            <div class="mt-3">
                <h6>ğŸ“¦ Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„ÙØ§ØªÙˆØ±Ø©:</h6>
                <div class="table-responsive">
                    <table class="table table-sm table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>Ø§Ù„Ù…Ù†ØªØ¬</th>
                                <th class="text-center">Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø£ØµÙ„ÙŠØ©</th>
                                <th class="text-center">Ù…ØªØ§Ø­ Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹</th>
                                <th class="text-end">Ø§Ù„Ø³Ø¹Ø±</th>
                                <th class="text-center">Ø¥Ø¬Ø±Ø§Ø¡</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${itemsHtml}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    `;
}

// Display invoice not found
function displayInvoiceNotFound(searchNumber, availableInvoices) {
    const searchResult = document.getElementById('invoiceSearchResult');
    
    const availableNumbers = availableInvoices.map(inv => `
        <button class="btn btn-outline-primary btn-sm me-2 mb-2" onclick="useInvoiceNumber('${inv.invoiceNumber || inv.number}')">
            ${inv.invoiceNumber || inv.number}
        </button>
    `).join('');
    
    searchResult.innerHTML = `
        <div class="alert alert-warning">
            <div class="d-flex align-items-center mb-3">
                <i class="fas fa-exclamation-triangle fa-2x text-warning me-3"></i>
                <div>
                    <h6 class="mb-1">âš ï¸ Ø§Ù„ÙØ§ØªÙˆØ±Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©</h6>
                    <small class="text-muted">Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙØ§ØªÙˆØ±Ø© Ø¨Ø±Ù‚Ù…: <strong>${searchNumber}</strong></small>
                </div>
            </div>
            
            <div class="mt-3">
                <h6>ğŸ“‹ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©:</h6>
                <div class="available-invoices">
                    ${availableNumbers}
                </div>
                <small class="text-muted d-block mt-2">Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø£ÙŠ Ø±Ù‚Ù… ÙØ§ØªÙˆØ±Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡</small>
            </div>
        </div>
    `;
}

// Display all invoices
function displayAllInvoices(invoices) {
    const searchResult = document.getElementById('invoiceSearchResult');
    
    const invoicesHtml = invoices.map(invoice => `
        <tr>
            <td><code>${invoice.invoiceNumber || invoice.number}</code></td>
            <td>${invoice.customerName || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</td>
            <td>${new Date(invoice.invoiceDate || invoice.date).toLocaleDateString('ar-EG')}</td>
            <td class="text-end">${(invoice.totalAmount || invoice.total || 0).toFixed(2)} Ø¬.Ù…</td>
            <td class="text-center">
${getInvoiceStatusBadge(invoice.status || 'Paid')}
            </td>
            <td class="text-center">
                <button class="btn btn-sm btn-primary" onclick="useInvoiceNumber('${invoice.invoiceNumber || invoice.number}')">
                    <i class="fas fa-check"></i> Ø§Ø³ØªØ®Ø¯Ø§Ù…
                </button>
            </td>
        </tr>
    `).join('');
    
    searchResult.innerHTML = `
        <div class="alert alert-info">
            <div class="d-flex align-items-center mb-3">
                <i class="fas fa-list fa-2x text-info me-3"></i>
                <div>
                    <h6 class="mb-1">ğŸ“‹ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙÙˆØ§ØªÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©</h6>
                    <small class="text-muted">Ø¥Ø¬Ù…Ø§Ù„ÙŠ ${invoices.length} ÙØ§ØªÙˆØ±Ø©</small>
                </div>
            </div>
            
            <div class="table-responsive">
                <table class="table table-sm table-striped">
                    <thead class="table-dark">
                        <tr>
                            <th>Ø±Ù‚Ù… Ø§Ù„ÙØ§ØªÙˆØ±Ø©</th>
                            <th>Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„</th>
                            <th>Ø§Ù„ØªØ§Ø±ÙŠØ®</th>
                            <th class="text-end">Ø§Ù„Ù…Ø¨Ù„Øº</th>
                            <th class="text-center">Ø§Ù„Ø­Ø§Ù„Ø©</th>
                            <th class="text-center">Ø¥Ø¬Ø±Ø§Ø¡</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${invoicesHtml}
                    </tbody>
                </table>
            </div>
        </div>
    `;
}

// Use selected invoice number
function useInvoiceNumber(invoiceNumber) {
    const invoiceInput = document.getElementById('originalInvoiceNumber');
    if (invoiceInput) {
        invoiceInput.value = invoiceNumber;
        invoiceInput.classList.add('is-valid');
        showMessage(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: ${invoiceNumber}`, 'success');
        
        // Automatically search for the selected invoice
        setTimeout(() => {
            searchOriginalInvoice();
        }, 500);
    }
}

// Escape HTML to prevent XSS
function escapeHtml(unsafe) {
    return (unsafe || '')
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// Attach event listeners to return buttons
function attachReturnButtonListeners() {
    console.log('ğŸ”— Ø¬Ø§Ø±ÙŠ Ø±Ø¨Ø· Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¶Ø§ÙØ©...');
    
    const returnButtons = document.querySelectorAll('.add-to-return-btn');
    console.log(`ğŸ” ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${returnButtons.length} Ø²Ø±`);
    
    returnButtons.forEach((button, index) => {
        console.log(`ğŸ”— Ø±Ø¨Ø· Ø§Ù„Ø²Ø± ${index + 1}:`, button);
        
        // Remove any existing listeners
        button.removeEventListener('click', handleReturnButtonClick);
        
        // Add new listener
        button.addEventListener('click', handleReturnButtonClick);
    });
    
    console.log(`âœ… ØªÙ… Ø±Ø¨Ø· ${returnButtons.length} Ø²Ø± Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹`);
}

// Handle return item add button click (onclick method)
function handleReturnItemAdd(button) {
    console.log('ğŸ”„ Return item add clicked:', button);
    
    try {
        if (!button) {
            console.error('âŒ Button not provided');
            alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø²Ø±');
            return;
        }
        
        // Disable button immediately to prevent multiple clicks
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø¶Ø§ÙØ©...';
        
        const productId = button.getAttribute('data-product-id');
        const productName = button.getAttribute('data-product-name');
        const availableQuantity = parseInt(button.getAttribute('data-quantity'));
        const price = parseFloat(button.getAttribute('data-price'));
        
        console.log('ğŸ“Š Button data:', { productId, productName, availableQuantity, price });
        
        // Check if product is already in cart for return
        const existingReturnItem = cart.find(item => 
            (item.productId == productId || item.name === productName) && item.quantity < 0
        );
        
        if (existingReturnItem) {
            const currentReturnQuantity = Math.abs(existingReturnItem.quantity);
            const totalReturnQuantity = currentReturnQuantity + 1;
            
            if (totalReturnQuantity > availableQuantity) {
                alert(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙƒØ«Ø± Ù…Ù† ${availableQuantity} Ù‚Ø·Ø¹Ø© Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†ØªØ¬!\nØ§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ø³Ù„Ø©: ${currentReturnQuantity}`);
                // Re-enable button
                button.disabled = false;
                button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
                return;
            }
            
            console.log(`âš ï¸ Product already in cart for return. Current: ${currentReturnQuantity}, Adding: 1, Total will be: ${totalReturnQuantity}`);
        }
        
        if (!productName) {
            console.error('âŒ Product name is missing');
            alert('âŒ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬ Ù…ÙÙ‚ÙˆØ¯');
            // Re-enable button
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
            return;
        }
        
        if (isNaN(availableQuantity) || availableQuantity <= 0) {
            console.error('âŒ Invalid available quantity:', availableQuantity);
            alert('âŒ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
            // Re-enable button
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
            return;
        }
        
        if (isNaN(price) || price < 0) {
            console.error('âŒ Invalid price:', price);
            alert('âŒ Ø§Ù„Ø³Ø¹Ø± ØºÙŠØ± ØµØ­ÙŠØ­');
            // Re-enable button
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
            return;
        }
        
        console.log('âœ… All validations passed, calling addProductToCart for return...');
        
        // Ensure we're in return mode
        if (!isReturnMode) {
            console.log('ğŸ”„ Switching to return mode...');
            isReturnMode = true;
        }
        
        // Add to cart using productId and productName
        addProductToCart(productId || 0, productName, price);
        
        // Re-enable button after successful addition
        setTimeout(() => {
            button.disabled = false;
            button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
        }, 1000); // Re-enable after 1 second
        
    } catch (error) {
        console.error('âŒ Error in handleReturnItemAdd:', error);
        alert('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬: ' + error.message);
        // Re-enable button on error
        button.disabled = false;
        button.innerHTML = '<i class="fas fa-plus"></i> Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹';
    }
}

// Handle return button click (event listener method - backup)
function handleReturnButtonClick(event) {
    event.preventDefault();
    event.stopPropagation();
    
    const button = event.target.closest('.add-to-return-btn');
    if (!button) {
        console.error('âŒ Button not found');
        return;
    }
    
    handleReturnItemAdd(button);
}

// Add item to return cart
function addToReturnCart(itemName, maxQuantity, price) {
    console.log('ğŸ”„ Adding to return cart:', { itemName, maxQuantity, price });
    
    try {
        // Check if we're in return or exchange mode
        const currentMode = getCurrentMode();
        console.log('ğŸ” Current mode:', currentMode);
        
        if (getCurrentMode() !== 'return' && getCurrentMode() !== 'exchange') {
            showMessage('âŒ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹ Ø£Ùˆ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù„Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª', 'error');
            return;
            }
        
        // Prompt user for quantity to return
        let quantityToReturn = prompt(`ÙƒÙ… ÙƒÙ…ÙŠØ© ØªØ±ÙŠØ¯ Ø¥Ø±Ø¬Ø§Ø¹Ù‡Ø§ Ù…Ù† "${itemName}"ØŸ\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: ${maxQuantity}`, '1');
        
        if (quantityToReturn === null) {
            console.log('ğŸš« User cancelled quantity input');
            return; // User cancelled
        }
        
        quantityToReturn = parseInt(quantityToReturn);
        console.log('ğŸ“Š Parsed quantity:', quantityToReturn);
        
        // Validate quantity
        if (isNaN(quantityToReturn) || quantityToReturn <= 0) {
            console.error('âŒ Invalid quantity:', quantityToReturn);
            showMessage('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ…ÙŠØ© ØµØ­ÙŠØ­Ø©', 'error');
            return;
        }
        
        if (quantityToReturn > maxQuantity) {
            console.error('âŒ Quantity exceeds maximum:', quantityToReturn, '>', maxQuantity);
            showMessage(`âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙƒØ«Ø± Ù…Ù† ${maxQuantity} Ù‚Ø·Ø¹Ø©`, 'error');
            return;
        }
        
        // Make sure cart is available globally
        if (typeof cart === 'undefined') {
            console.log('ğŸ›’ Initializing global cart array');
            window.cart = [];
        }
        
        console.log('ğŸ›’ Current cart:', cart);
        
        // Check if item already exists in cart
        const existingItem = cart.find(item => item.name === itemName);
        console.log('ğŸ” Existing item:', existingItem);
        
        if (existingItem) {
            // Update existing item quantity
            const newQuantity = Math.abs(existingItem.quantity) + quantityToReturn;
            if (newQuantity > maxQuantity) {
                console.error('âŒ Total quantity exceeds maximum:', newQuantity, '>', maxQuantity);
                showMessage(`âŒ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…ÙØ±Ø¬Ø¹Ø© Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØªØ¬Ø§ÙˆØ² ${maxQuantity}`, 'error');
                return;
            }
            existingItem.quantity = -newQuantity; // Negative for returns
            existingItem.total = -(existingItem.price * newQuantity);
            console.log('âœ… Updated existing item:', existingItem);
        } else {
            // Add new item to cart with negative quantity (for returns)
            const returnItem = {
                id: Date.now(), // Unique ID
                productId: null, // Will be resolved on server side by product name
                name: itemName,
                price: price,
                quantity: -quantityToReturn, // Negative quantity for returns
                total: Math.round(-(price * quantityToReturn) * 100) / 100, // Negative total for returns, rounded
                isReturn: true,
                discount: 0
            };
            cart.push(returnItem);
            console.log('âœ… Added new return item:', returnItem);
        }
        
        console.log('ğŸ›’ Updated cart:', cart);
        
        // Update cart display
        if (typeof updateCartDisplay === 'function') {
            updateCartDisplay();
            console.log('âœ… Cart display updated');
        } else {
            console.warn('âš ï¸ updateCartDisplay function not available');
        }
        
        if (typeof updateCartSummary === 'function') {
            updateCartSummary();
            console.log('âœ… Cart summary updated');
        } else {
            console.warn('âš ï¸ updateCartSummary function not available');
        }
        
        if (typeof updateProcessButtonState === 'function') {
            updateProcessButtonState();
            console.log('âœ… Process button state updated');
        } else {
            console.warn('âš ï¸ updateProcessButtonState function not available');
        }
        
        // Show success message
        showMessage(`âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© ${quantityToReturn} Ù…Ù† "${itemName}" Ø¥Ù„Ù‰ Ø³Ù„Ø© ${getCurrentMode() === 'return' ? 'Ø§Ù„Ø¥Ø±Ø¬Ø§Ø¹' : 'Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„'}`, 'success');
        
        console.log('ğŸ‰ addToReturnCart completed successfully');
        
    } catch (error) {
        console.error('âŒ Error in addToReturnCart:', error);
        showMessage('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬: ' + error.message, 'error');
    }
}

// Update cart display in the UI
function updateCartDisplay() {
    console.log('ğŸ”„ Updating cart display...');
    
    // Try multiple possible cart container IDs/classes
    const cartContainer = document.getElementById('cartItems') || 
                         document.getElementById('cart-items') || 
                         document.querySelector('.cart-items') ||
                         document.querySelector('#cartTable tbody');
    
    if (!cartContainer) {
        console.error('âŒ Cart container not found! Tried: cartItems, cart-items, .cart-items, #cartTable tbody');
        return;
    }
    
    console.log('âœ… Found cart container:', cartContainer.id || cartContainer.className);
    
    // Clear existing items
    cartContainer.innerHTML = '';
    
    if (cart.length === 0) {
        cartContainer.innerHTML = `
            <tr id="emptyCart">
                <td colspan="6" class="text-center text-muted">
                    <i class="fas fa-shopping-cart fa-2x mb-2"></i>
                    <br>
                    Ø§Ù„Ø³Ù„Ø© ÙØ§Ø±ØºØ© - Ù‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª
                </td>
            </tr>
        `;
        return;
    }
    
    // Display cart items
    cart.forEach((item, index) => {
        const isReturnItem = item.quantity < 0;
        const displayQuantity = Math.abs(item.quantity);
        const itemSubTotal = Math.abs(item.price * item.quantity);
        const displayTotal = Math.abs(item.total || itemSubTotal);
        const discount = item.discount || 0;
        
        const rowClass = isReturnItem ? 'return-item' : '';
        const quantityDisplay = isReturnItem ? `-${displayQuantity}` : displayQuantity;
        const totalDisplay = isReturnItem ? `-${displayTotal.toFixed(2)}` : displayTotal.toFixed(2);
        
        const itemHtml = `
            <tr class="${rowClass}" data-index="${index}">
                <td>
                    <div class="d-flex align-items-center">
                        ${isReturnItem ? 'â†©ï¸' : 'ğŸ“¦'}
                        <strong>${item.name}</strong>
                        ${item.color ? `<span class="badge bg-info ms-1">${item.color}</span>` : ''}
                        ${item.size ? `<span class="badge bg-secondary ms-1">${item.size}</span>` : ''}
                        ${isReturnItem ? '<span class="badge bg-danger ms-2">Ø¥Ø±Ø¬Ø§Ø¹</span>' : ''}
                    </div>
                </td>
                <td>${item.price.toFixed(2)} Ø¬.Ù…</td>
                <td>
                    <div class="quantity-controls">
                        ${!isReturnItem ? `
                            <button class="btn btn-sm btn-outline-secondary" onclick="decreaseQuantity(${index})">
                                â–
                            </button>
                            <span class="quantity-display mx-2">${displayQuantity}</span>
                            <button class="btn btn-sm btn-outline-secondary" onclick="increaseQuantity(${index})">
                                â•
                            </button>
                        ` : `
                            <span class="text-danger fw-bold">${quantityDisplay}</span>
                        `}
                    </div>
                </td>
                <td>
                    <input type="number" class="form-control form-control-sm discount-input" 
                           value="${discount}" min="0" step="0.01" 
                           onchange="updateDiscount(${index}, this.value)"
                           ${isReturnItem ? 'disabled' : ''}
                           placeholder="0.00">
                </td>
                <td class="${isReturnItem ? 'text-danger' : 'text-success'} fw-bold">
                    ${totalDisplay} Ø¬.Ù…
                    ${discount > 0 ? `<br><small class="text-muted">Ø®ØµÙ…: ${discount} Ø¬.Ù…</small>` : ''}
                </td>
                <td>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeFromCart(${index})">
                        ğŸ—‘ï¸
                    </button>
                </td>
            </tr>
        `;
        
        cartContainer.insertAdjacentHTML('beforeend', itemHtml);
    });
}

// Update cart summary (totals, counts, etc.)
function updateCartSummary() {
    console.log('ğŸ’° Updating cart summary...');
    
    try {
        if (!cart || cart.length === 0) {
            // Reset all summaries to zero - using correct HTML element IDs
            updateSummaryElement('subtotal', '0.00 Ø¬.Ù…');
            updateSummaryElement('totalDiscount', '0.00 Ø¬.Ù…');
            updateSummaryElement('grandTotal', '0.00 Ø¬.Ù…');
            console.log('ğŸ’° Summary reset to zero');
            return;
        }
        
        let totalItems = 0;
        let totalAmount = 0;
        let totalDiscount = 0;
        let returnItems = 0;
        let saleItems = 0;
        
        cart.forEach(item => {
            const quantity = Math.abs(item.quantity);
            const itemSubTotal = item.price * item.quantity; // Don't use Math.abs here
            const itemTotal = item.total || itemSubTotal;
            const itemDiscount = item.discount || 0;
            const discountAmount = itemDiscount; // Direct amount, not percentage
            
            // Ensure item.total is correctly calculated with discount
            if (item.discount > 0) {
                const calculatedTotal = Math.abs(itemSubTotal) - discountAmount;
                item.total = item.quantity < 0 ? -calculatedTotal : calculatedTotal;
                
                // Log discount calculation for debugging
                console.log(`ğŸ’° Item discount calculation for ${item.name}:`, {
                    subtotal: Math.abs(itemSubTotal).toFixed(2),
                    discount: item.discount.toFixed(2),
                    total: item.total.toFixed(2),
                    mode: item.quantity < 0 ? 'return' : 'sale',
                    discountType: 'direct_amount',
                    savings: discountAmount.toFixed(2),
                    percentage: ((discountAmount / Math.abs(itemSubTotal)) * 100).toFixed(1) + '%',
                    validation: discountAmount <= Math.abs(itemSubTotal) ? 'valid' : 'invalid',
                    finalPrice: calculatedTotal.toFixed(2),
                    timestamp: new Date().toLocaleTimeString(),
                    itemId: item.id
                });
            }
            
            if (item.quantity < 0) {
                // Return item
                returnItems += quantity;
                totalAmount += itemSubTotal; // Add negative value for returns
                totalDiscount += discountAmount; // Add discount for returns
            } else {
                // Sale item
                saleItems += quantity;
                totalAmount += itemSubTotal; // Add positive value for sales
                totalDiscount += discountAmount; // Add discount for sales
            }
            
            totalItems += quantity;
        });
        
        // Get shipping cost
        const shippingCostInput = document.getElementById('shippingCost');
        const shippingCost = parseFloat(shippingCostInput?.value || 0);
        
        const finalTotal = totalAmount - totalDiscount + shippingCost;
        
        // Update UI elements - using correct HTML element IDs
        updateSummaryElement('subtotal', Math.abs(totalAmount).toFixed(2) + ' Ø¬.Ù…');
        updateSummaryElement('totalDiscount', Math.abs(totalDiscount).toFixed(2) + ' Ø¬.Ù…');
        updateSummaryElement('shippingCostDisplay', shippingCost.toFixed(2) + ' Ø¬.Ù…');
        updateSummaryElement('grandTotal', finalTotal.toFixed(2) + ' Ø¬.Ù…');
        
        // Log detailed calculation for debugging
        console.log('ğŸ’° Detailed calculation:', {
            totalAmount: totalAmount.toFixed(2),
            totalDiscount: totalDiscount.toFixed(2),
            shippingCost: shippingCost.toFixed(2),
            finalTotal: finalTotal.toFixed(2),
            items: cart.map(item => ({
                name: item.name,
                price: item.price,
                quantity: item.quantity,
                discount: item.discount,
                subtotal: (Math.abs(item.price * item.quantity)).toFixed(2),
                discountAmount: (item.discount || 0).toFixed(2), // Direct amount
                total: item.total.toFixed(2)
            }))
        });
        
        // Update final total color based on positive/negative
        const finalTotalElement = document.getElementById('grandTotal');
        if (finalTotalElement) {
            finalTotalElement.className = finalTotal >= 0 ? 'summary-value success' : 'summary-value danger';
        }
        
        console.log('ğŸ’° Summary updated:', {
            totalItems,
            saleItems,
            returnItems,
            totalAmount,
            totalDiscount,
            shippingCost,
            finalTotal
        });
        
        // Update remaining amount if payment input exists
        const amountPaidInput = document.getElementById('amountPaid');
        if (amountPaidInput && amountPaidInput.value) {
            const amountPaid = parseFloat(amountPaidInput.value || 0);
            const remaining = finalTotal - amountPaid;
            updateRemainingAmountDisplay(remaining);
        }
        
        // Remove automatic payment validation - let user control payment amount
        // if (typeof validatePaymentAmount === 'function') {
        //     validatePaymentAmount();
        // }
        
    } catch (error) {
        console.error('âŒ Error updating cart summary:', error);
    }
}

// Helper function to update summary elements safely
function updateSummaryElement(elementId, value) {
    const element = document.getElementById(elementId);
    if (element) {
        const oldValue = element.textContent;
        element.textContent = value;
        console.log(`ğŸ“Š Updated ${elementId}: ${oldValue} â†’ ${value}`);
    } else {
        console.warn(`âš ï¸ Summary element not found: ${elementId}`);
    }
}

// Increase item quantity in cart
function increaseQuantity(index) {
    if (index >= 0 && index < cart.length) {
        const item = cart[index];
        if (item.quantity > 0) { // Only for sale items, not returns
            item.quantity += 1;
            
            // Recalculate total with discount
            const itemSubTotal = Math.abs(item.price * item.quantity);
            const discountAmount = item.discount || 0; // Direct amount
            item.total = Math.round((itemSubTotal - discountAmount) * 100) / 100;
            
            updateCartDisplay();
            updateCartSummary();
            if (typeof updateProcessButtonState === 'function') {
            updateProcessButtonState();
            }
            showMessage(`âœ… ØªÙ… Ø²ÙŠØ§Ø¯Ø© ÙƒÙ…ÙŠØ© "${item.name}"`, 'success');
        }
    }
}

// Decrease item quantity in cart
function decreaseQuantity(index) {
    if (index >= 0 && index < cart.length) {
        const item = cart[index];
        if (item.quantity > 1) { // Keep at least 1
            item.quantity -= 1;
            
            // Recalculate total with discount
            const itemSubTotal = Math.abs(item.price * item.quantity);
            const discountAmount = item.discount || 0; // Direct amount
            item.total = Math.round((itemSubTotal - discountAmount) * 100) / 100;
            
            updateCartDisplay();
            updateCartSummary();
            if (typeof updateProcessButtonState === 'function') {
            updateProcessButtonState();
            }
            showMessage(`âœ… ØªÙ… ØªÙ‚Ù„ÙŠÙ„ ÙƒÙ…ÙŠØ© "${item.name}"`, 'success');
        } else if (item.quantity === 1) {
            // Remove item if quantity becomes 0
            removeFromCart(index);
        }
    }
}

// Remove item from cart
function removeFromCart(index) {
    if (index >= 0 && index < cart.length) {
        const item = cart[index];
        const itemName = item.name;
        cart.splice(index, 1);
        updateCartDisplay();
        updateCartSummary();
        if (typeof updateProcessButtonState === 'function') {
        updateProcessButtonState();
        }
        showMessage(`ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù "${itemName}" Ù…Ù† Ø§Ù„Ø³Ù„Ø©`, 'info');
    }
}

// Update discount for an item
function updateDiscount(index, discountValue) {
    if (index >= 0 && index < cart.length) {
        const item = cart[index];
        const discount = parseFloat(discountValue) || 0;
        
        // Apply discount as direct amount (not percentage)
        const itemSubTotal = Math.abs(item.price * item.quantity);
        item.discount = validateDiscountAmount(discount, itemSubTotal); // Validate discount amount
        
        // Recalculate total with discount
        const discountAmount = item.discount; // Direct amount
        const newTotal = itemSubTotal - discountAmount;
        
        // Keep negative for return items
        item.total = item.quantity < 0 ? -newTotal : newTotal;
        
        updateCartDisplay();
        updateCartSummary();
        
        console.log(`ğŸ’° Discount updated for ${item.name}: ${discount} Ø¬.Ù… (Direct amount)`);
        
        // Show confirmation message
        if (discount > 0) {
            const originalDiscount = parseFloat(discountValue) || 0;
            if (originalDiscount > itemSubTotal) {
                showMessage(`âš ï¸ ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ØµÙ… Ù…Ù† ${originalDiscount} Ø¥Ù„Ù‰ ${discount} Ø¬.Ù… (Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØªØ¬Ø§ÙˆØ² Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù†ØªØ¬)`, 'warning');
            } else {
                showMessage(`âœ… ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø®ØµÙ… ${discount} Ø¬.Ù… Ø¹Ù„Ù‰ "${item.name}"`, 'success');
            }
        } else {
            showMessage(`âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø®ØµÙ… Ù…Ù† "${item.name}"`, 'info');
        }
    }
}

// Initialize customer form validation
function initializeCustomerValidation() {
    console.log('ğŸ”§ ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…ÙŠÙ„...');
    
    // Add event listeners for real-time validation
    const nameField = document.getElementById('customerName');
    const phoneField = document.getElementById('customerPhoneInput');
    const emailField = document.getElementById('customerEmail');
    const additionalPhoneField = document.getElementById('customerAdditionalPhone');
    const phoneSearchField = document.getElementById('customerPhone');
    
    // Name field validation
    if (nameField) {
        nameField.addEventListener('blur', validateCustomerForm);
        nameField.addEventListener('input', function() {
            if (this.value.trim().length >= 2) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
            } else if (this.value.trim().length > 0) {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            } else {
                this.classList.remove('is-valid', 'is-invalid');
            }
        });
    }
    
    // Phone field validation
    if (phoneField) {
        phoneField.addEventListener('blur', validateCustomerForm);
        phoneField.addEventListener('input', function() {
            // Format phone number as user types
            let value = this.value.replace(/\D/g, '');
            if (value.length > 11) value = value.substring(0, 11);
            this.value = value;
            
            if (/^[0-9]{11}$/.test(value)) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
            } else if (value.length > 0) {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            } else {
                this.classList.remove('is-valid', 'is-invalid');
            }
        });
    }
    
    // Email field validation
    if (emailField) {
        emailField.addEventListener('blur', validateCustomerForm);
        emailField.addEventListener('input', function() {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (this.value.trim() === '') {
                this.classList.remove('is-valid', 'is-invalid');
            } else if (emailRegex.test(this.value.trim())) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
            } else {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            }
        });
    }
    
    // Additional phone field validation
    if (additionalPhoneField) {
        additionalPhoneField.addEventListener('input', function() {
            // Format phone number as user types
            let value = this.value.replace(/\D/g, '');
            if (value.length > 11) value = value.substring(0, 11);
            this.value = value;
            
            if (value === '') {
                this.classList.remove('is-valid', 'is-invalid');
            } else if (/^[0-9]{11}$/.test(value)) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
            } else {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            }
        });
    }
    
    // Phone search field formatting
    if (phoneSearchField) {
        phoneSearchField.addEventListener('input', function() {
            // Format phone number as user types
            let value = this.value.replace(/\D/g, '');
            if (value.length > 11) value = value.substring(0, 11);
            this.value = value;
        });
        
        // Allow Enter key to trigger search
        phoneSearchField.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchCustomerByPhone();
            }
        });
    }
    
    console.log('âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
}

// Initialize mode-specific features
function initializeModeFeatures() {
    console.log('ğŸ”§ ØªÙ‡ÙŠØ¦Ø© Ù…ÙŠØ²Ø§Øª Ø£ÙˆØ¶Ø§Ø¹ Ø§Ù„ØªØ´ØºÙŠÙ„...');
    
    // Add event listeners for invoice search
    const invoiceInput = document.getElementById('originalInvoiceNumber');
    if (invoiceInput) {
        // Allow Enter key to trigger search
        invoiceInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchOriginalInvoice();
            }
        });
        
        // Real-time validation
        invoiceInput.addEventListener('input', function() {
            const value = this.value.trim();
            if (value.length >= 3) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
            } else if (value.length > 0) {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            } else {
                this.classList.remove('is-valid', 'is-invalid');
            }
        });
    }
    
    // Add event listeners for reason select
    const reasonSelect = document.getElementById('reasonSelect');
    if (reasonSelect) {
        reasonSelect.addEventListener('change', function() {
            if (this.value) {
                this.classList.remove('is-invalid');
                this.classList.add('is-valid');
                
                // Show additional options based on reason
                updateAdditionalOptions(this.value);
            } else {
                this.classList.remove('is-valid');
                this.classList.add('is-invalid');
            }
        });
    }
    
    // Initialize default mode with stability
    setTimeout(() => {
        switchMode('sale');
        
        // Force show QR scanner mode and ensure visibility
        setTimeout(() => {
            forceShowQRMode();
            switchSearchMode('qr');
        }, 200);
    }, 300);
    
    console.log('âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù…ÙŠØ²Ø§Øª Ø£ÙˆØ¶Ø§Ø¹ Ø§Ù„ØªØ´ØºÙŠÙ„');
}

// Update additional options based on return reason
function updateAdditionalOptions(reason) {
    const shippingRefund = document.getElementById('includeShippingRefund');
    const exchangeWithDifference = document.getElementById('exchangeWithDifference');
    
    if (!shippingRefund || !exchangeWithDifference) return;
    
    // Reset options
    shippingRefund.checked = false;
    exchangeWithDifference.checked = false;
    
    // Set default options based on reason
    switch (reason) {
        case 'defective':
        case 'damaged':
        case 'quality_issue':
            shippingRefund.checked = true; // Automatically include shipping refund for defective items
            break;
        case 'size_issue':
        case 'customer_change':
            exchangeWithDifference.checked = true; // Suggest exchange for size/preference issues
            break;
        default:
            // Keep defaults unchecked
            break;
    }
    
    console.log(`ğŸ“‹ ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø³Ø¨Ø¨: ${reason}`);
}

// Export functions to global scope for onclick handlers
window.getCurrentMode = getCurrentMode;
window.testJS = testJS;
window.testReturnCart = testReturnCart;
window.addItemDirectly = addItemDirectly;
window.testCartDisplay = testCartDisplay;
window.testProductQuantity = testProductQuantity;
window.testManualUpdate = testManualUpdate;
window.searchProducts = searchProducts;
window.getProductSuggestions = getProductSuggestions;
window.initializeLiveSearch = initializeLiveSearch;
window.displaySearchResults = displaySearchResults;
window.selectSearchResult = selectSearchResult;
window.addProductToCart = addProductToCart;
window.updateQRStatus = updateQRStatus;
window.clearQRInput = clearQRInput;
window.debugAllProducts = debugAllProducts;
window.testQRSearch = testQRSearch;
window.simpleQRSearch = simpleQRSearch;
window.simpleBarcodeSearch = simpleBarcodeSearch;
window.quickBarcode = quickBarcode;
window.testManualInput = testManualInput;
window.simulateEnter = simulateEnter;
window.testNow = testNow;
window.performAdvancedSearch = performAdvancedSearch;
window.displayAdvancedSearchResults = displayAdvancedSearchResults;
window.initializeSearchMode = initializeSearchMode;
window.initializeQRMode = initializeQRMode;
window.initializeNameSearchMode = initializeNameSearchMode;
window.initializeAdvancedSearchMode = initializeAdvancedSearchMode;
window.loadSearchFilters = loadSearchFilters;
window.clearProductNameSearch = clearProductNameSearch;
window.showPopularProducts = showPopularProducts;
window.clearAdvancedFilters = clearAdvancedFilters;
window.hideToast = hideToast;
window.closeToast = closeToast;
window.processScannerInput = processScannerInput;
window.refocusQRInput = refocusQRInput;
window.playSuccessSound = playSuccessSound;
window.updateScannerStats = updateScannerStats;
window.initializeScannerStats = initializeScannerStats;
window.forceShowQRMode = forceShowQRMode;
window.startQRVisibilityMonitor = startQRVisibilityMonitor;
window.fixQRDisplay = fixQRDisplay;
window.isUserInteractingWithOtherElements = isUserInteractingWithOtherElements;
window.disableQRForcing = disableQRForcing;
window.testAllButtons = testAllButtons;
window.switchMode = switchMode;
window.switchSearchMode = switchSearchMode;
window.clearCart = clearCart;
window.addToCart = addToCart;
window.searchCustomerByPhone = searchCustomerByPhone;
window.handleCustomerSelection = handleCustomerSelection;
window.fillCustomerDataFromSearch = fillCustomerDataFromSearch;
window.updateCustomerSelect = updateCustomerSelect;
window.clearCustomerData = clearCustomerData;
window.validateCustomerForm = validateCustomerForm;
window.searchOriginalInvoice = searchOriginalInvoice;
window.showAllInvoices = showAllInvoices;
window.useInvoiceNumber = useInvoiceNumber;
window.addToReturnCart = addToReturnCart;
window.handleReturnItemAdd = handleReturnItemAdd;
window.attachReturnButtonListeners = attachReturnButtonListeners;
window.handleReturnButtonClick = handleReturnButtonClick;
window.updateCartDisplay = updateCartDisplay;
window.updateCartSummary = updateCartSummary;
window.updateSummaryElement = updateSummaryElement;
window.increaseQuantity = increaseQuantity;
window.decreaseQuantity = decreaseQuantity;
window.removeFromCart = removeFromCart;
window.updateDiscount = updateDiscount;
window.processTransaction = processTransaction;
window.collectCustomerData = collectCustomerData;
window.prepareTransactionData = prepareTransactionData;
window.getInvoiceTypeFromMode = getInvoiceTypeFromMode;
window.getModeName = getModeName;
window.sendTransactionToServer = sendTransactionToServer;
window.handleTransactionSuccess = handleTransactionSuccess;
window.verifyInventoryUpdates = verifyInventoryUpdates;
window.handleTransactionError = handleTransactionError;
window.resetTransactionForm = resetTransactionForm;
window.printInvoice = printInvoice;
window.showMessage = showMessage;



// Helper function to calculate item total with discount
function calculateItemTotalWithDiscount(item) {
    const itemSubTotal = Math.abs(item.price * item.quantity);
    const discountAmount = item.discount || 0; // Direct amount
    const total = itemSubTotal - discountAmount;
    const roundedTotal = Math.round(total * 100) / 100; // Round to 2 decimal places
    return item.quantity < 0 ? -roundedTotal : roundedTotal;
}

// Helper function to validate discount amount
function validateDiscountAmount(discount, itemSubTotal) {
    const maxDiscount = itemSubTotal; // Cannot discount more than the subtotal
    const validatedDiscount = Math.max(0, Math.min(discount, maxDiscount));
    
    if (discount > maxDiscount) {
        console.warn(`âš ï¸ Discount ${discount} exceeds subtotal ${itemSubTotal}, adjusted to ${validatedDiscount}`);
    }
    
    return validatedDiscount;
}

// Add CSS for return items if not already added
if (!document.querySelector('#return-item-styles')) {
    const style = document.createElement('style');
    style.id = 'return-item-styles';
    style.textContent = `
        .return-item {
            background-color: #fff2f2 !important;
            border-left: 4px solid #dc3545 !important;
        }
        .return-item .badge {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    `;
    document.head.appendChild(style);
}

console.log('ğŸ“„ Ù…Ù„Ù cashier.js ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡ Ø¨Ù†Ø¬Ø§Ø­');

// Quick test functions available in console:
console.log('ğŸ§ª Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:');
console.log('  - testPaymentAmount(100) - Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø¨Ù„Øº Ù…Ø­Ø¯Ø¯');
console.log('  - testRealTimeCalculations() - Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„');
console.log('  - testAllCashierCalculations() - Ø§Ø®ØªØ¨Ø§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª');
console.log('  - testPaymentSystem() - Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯ÙØ¹');
console.log('ğŸ’¡ Ù…Ø«Ø§Ù„: testPaymentAmount(50) Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹ 50 Ø¬.Ù…');
console.log('ğŸ’¡ Ù…Ø«Ø§Ù„: testSpecificAmount() Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø¨Ù„Øº 50 Ø¬.Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯');
console.log('ğŸ’¡ Ù…Ø«Ø§Ù„: testShippingCost() Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù…ØµØ§Ø±ÙŠÙ Ø§Ù„Ø´Ø­Ù†');

// Test the specific amount mentioned by user
function testSpecificAmount() {
    console.log('ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø­Ø¯Ø¯: 50 Ø¬.Ù…');
    testPaymentAmount(50);
    
    // Expected results:
    // - Grand Total: 620.00 Ø¬.Ù… (if test items are loaded)
    // - Amount Paid: 50.00 Ø¬.Ù…
    // - Remaining: 570.00 Ø¬.Ù…
    
    console.log('ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©:');
    console.log('  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: 620.00 Ø¬.Ù…');
    console.log('  - Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹: 50.00 Ø¬.Ù…');
    console.log('  - Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: 570.00 Ø¬.Ù…');
}

window.testSpecificAmount = testSpecificAmount;

// Test Toast Notifications
function testToastNotifications() {
    console.log('ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Toast Notifications...');
    
    // Test different types of messages
    setTimeout(() => showMessage('âœ… Ø±Ø³Ø§Ù„Ø© Ù†Ø¬Ø§Ø­ - Toast ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­!', 'success'), 1000);
    setTimeout(() => showMessage('â„¹ï¸ Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª - Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø¬Ø§Ù‡Ø²', 'info'), 3000);
    setTimeout(() => showMessage('âš ï¸ Ø±Ø³Ø§Ù„Ø© ØªØ­Ø°ÙŠØ± - ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'warning'), 5000);
    setTimeout(() => showMessage('âŒ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ - Ø­Ø¯Ø« Ø®Ø·Ø£ Ù…Ø§', 'error'), 7000);
}

// Test specific messages mentioned by user
function testSpecificMessages() {
    console.log('ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©...');
    
    // Test the specific message from user's console
    setTimeout(() => showMessage('ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ§ØªÙˆØ±Ø©: 620.00 Ø¬.Ù… | Ø§Ù„Ù…Ø¯ÙÙˆØ¹: 250.00 Ø¬.Ù… | Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: 370.00 Ø¬.Ù…', 'info'), 1000);
    
    // Test cart calculations
    setTimeout(() => showMessage('ğŸ’° Cart Grand Total Calculation: {totalAmount: \'650.00\', totalDiscount: \'30.00\', finalTotal: \'620.00\'}', 'info'), 3000);
    
    // Test remaining amount
    setTimeout(() => showMessage('ğŸ’° Remaining Amount Calculation: {grandTotal: \'620.00\', amountPaid: \'250.00\', remaining: \'370.00\'}', 'info'), 5000);
}

// Comprehensive test for all cashier calculations
function testAllCashierCalculations() {
    console.log('ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠØ© ÙÙŠ Ø§Ù„ÙƒØ§Ø´ÙŠØ±...');
    
    // Test 1: Add test items to cart
    console.log('ğŸ“¦ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬Ø§Øª Ø§Ø®ØªØ¨Ø§Ø± Ù„Ù„Ø³Ù„Ø©...');
    
    // Clear cart first
    cart = [];
    
    // Add test items
    const testItems = [
        { id: 1, name: 'Ù…Ù†ØªØ¬ Ø§Ø®ØªØ¨Ø§Ø± 1', price: 100, quantity: 2, discount: 10 },
        { id: 2, name: 'Ù…Ù†ØªØ¬ Ø§Ø®ØªØ¨Ø§Ø± 2', price: 150, quantity: 1, discount: 0 },
        { id: 3, name: 'Ù…Ù†ØªØ¬ Ø§Ø®ØªØ¨Ø§Ø± 3', price: 200, quantity: 1, discount: 20 }
    ];
    
    cart = testItems.map(item => ({
        ...item,
        total: Math.round(((item.price * item.quantity) - item.discount) * 100) / 100
    }));
    
    console.log('ğŸ“¦ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©:', cart);
    
    // Test 2: Update cart summary
    console.log('ğŸ’° ØªØ­Ø¯ÙŠØ« Ù…Ù„Ø®Øµ Ø§Ù„Ø³Ù„Ø©...');
    updateCartSummary();
    
    // Test 3: Test payment scenarios
    console.log('ğŸ’³ Ø§Ø®ØªØ¨Ø§Ø± Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ø¯ÙØ¹...');
    
    const amountPaidInput = document.getElementById('amountPaid');
    if (amountPaidInput) {
        const testPayments = [
            { amount: 0, desc: 'ØºÙŠØ± Ù…Ø¯ÙÙˆØ¹' },
            { amount: 200, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø¬Ø²Ø¦ÙŠØ§Ù‹' },
            { amount: 520, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„' },
            { amount: 600, desc: 'Ù…Ø¯ÙÙˆØ¹ Ø²Ø§Ø¦Ø¯' }
        ];
        
        testPayments.forEach((test, index) => {
            setTimeout(() => {
                console.log(`ğŸ’³ Ø§Ø®ØªØ¨Ø§Ø± ${index + 1}: ${test.desc} - ${test.amount} Ø¬.Ù…`);
                amountPaidInput.value = test.amount;
                validatePaymentAmount();
            }, (index + 1) * 2000);
        });
    }
    
    // Test 4: Verify all calculations
    setTimeout(() => {
        console.log('âœ… ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª');
        console.log('ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:');
        console.log('  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø³Ù„Ø©:', getCartGrandTotal().toFixed(2), 'Ø¬.Ù…');
        console.log('  - Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø¯ÙÙˆØ¹:', amountPaidInput?.value || '0', 'Ø¬.Ù…');
        console.log('  - Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ:', (getCartGrandTotal() - parseFloat(amountPaidInput?.value || 0)).toFixed(2), 'Ø¬.Ù…');
    }, 10000);
}

// Initialize page when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸš€ ØªÙ‡ÙŠØ¦Ø© ØµÙØ­Ø© Ø§Ù„ÙƒØ§Ø´ÙŠØ±...');
    
    // Check if color/size modal is available
    const colorSizeModal = document.getElementById('colorSizeSelectionModal');
    if (colorSizeModal) {
        console.log('âœ… Color/Size selection modal found');
    } else {
        console.error('âŒ Color/Size selection modal not found!');
    }
    
    // Check if Bootstrap is available
    if (typeof bootstrap !== 'undefined') {
        console.log('âœ… Bootstrap is available');
    } else {
        console.error('âŒ Bootstrap is not available!');
    }
    
    // Test toast notifications after page load
    setTimeout(testToastNotifications, 2000);
    
    // Initialize default search mode (QR)
    setTimeout(() => {
        console.log('ğŸ”§ ØªÙ‡ÙŠØ¦Ø© ÙˆØ¶Ø¹ QR...');
        currentSearchMode = 'qr';
        initializeQRMode();
        
        // Also update UI to show QR mode is active
        const qrModeBtn = document.getElementById('qrModeBtn');
        if (qrModeBtn) {
            qrModeBtn.classList.add('active');
        }
        
        // Update QR status
        updateQRStatus('ready', 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø³Ø­');
        
        // ULTRA SIMPLE QR Setup
        const qrInput = document.getElementById('qrCodeInput');
        if (qrInput) {
            console.log('ğŸ”§ Setting up ULTRA SIMPLE QR...');
            
            // SUPER SIMPLE: Just handle Enter key
            qrInput.onkeydown = function(e) {
                console.log('Key pressed:', e.key);
                if (e.key === 'Enter') {
                    console.log('Enter detected!');
                    const code = this.value.trim();
                    console.log('Code:', code);
                    if (code) {
                        console.log('Searching for:', code);
                        this.value = '';
                        simpleQRSearch(code);
                    }
                }
            };
            
            qrInput.focus();
            console.log('âœ… ULTRA SIMPLE QR Ready!');
            console.log('ğŸ’¡ Type code and press Enter');
        } else {
            console.error('âŒ QR input not found!');
        }
        
        console.log('âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© ÙˆØ¶Ø¹ QR Ø¨Ù†Ø¬Ø§Ø­');
    }, 500); // Small delay to ensure DOM is fully loaded
    
    console.log('âœ… ØªÙ…Øª ØªÙ‡ÙŠØ¦Ø© ØµÙØ­Ø© Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­');
});

// Color and Size Selection Functions

// Show color/size selection for cart (manual selection)
function showColorSizeSelectionForCart() {
    // Get the first product from cart to use as reference
    if (!cart || cart.length === 0) {
        alert('âŒ Ø§Ù„Ø³Ù„Ø© ÙØ§Ø±ØºØ©! ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø£ÙˆÙ„Ø§Ù‹');
        return;
    }
    
    const firstProduct = cart[0];
    showColorSizeSelection(firstProduct.productId, firstProduct.name, firstProduct.price);
}

// Add product to cart with modal selection (for manual color/size selection)
function addProductToCartWithModal(productId, productName, productPrice) {
    showColorSizeSelection(productId, productName, productPrice);
}

function showColorSizeSelection(productId, productName, productPrice) {
    console.log('ğŸ¨ Showing color/size selection for:', productName);
    
    selectedProductInfo = { productId, productName, productPrice };

    // Reset selections
    const colorSelect = document.getElementById('selectedColor');
    const sizeSelect = document.getElementById('selectedSize');
    
    if (colorSelect) colorSelect.value = '';
    if (sizeSelect) sizeSelect.value = '';

    // Check if modal exists
    const modalElement = document.getElementById('colorSizeSelectionModal');
    if (!modalElement) {
        console.error('âŒ Color/Size selection modal not found!');
        alert('âŒ Ø®Ø·Ø£: Ù…ÙˆØ¯Ø§Ù„ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ù…Ù‚Ø§Ø³ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
        return;
    }

    // Check if Bootstrap is available
    if (typeof bootstrap === 'undefined') {
        console.error('âŒ Bootstrap is not available!');
        alert('âŒ Ø®Ø·Ø£: Bootstrap ØºÙŠØ± Ù…ØªØ§Ø­');
        return;
    }

    // Show modal
    try {
        // Remove any existing backdrop first
        const existingBackdrop = document.querySelector('.modal-backdrop');
        if (existingBackdrop) {
            existingBackdrop.remove();
        }
        
        // Remove modal-open class from body
        document.body.classList.remove('modal-open');
        
        // Create and show modal
        const modal = new bootstrap.Modal(modalElement, {
            backdrop: true,
            keyboard: true,
            focus: true
        });
        
        modal.show();
        console.log('âœ… Modal shown successfully');
        
        // Focus on first select after modal is shown
        setTimeout(() => {
            const firstSelect = document.getElementById('selectedColor');
            if (firstSelect) {
                firstSelect.focus();
            }
            
            // Verify confirm button is working
            const confirmButton = document.getElementById('confirmColorSize');
            if (confirmButton) {
                console.log('âœ… Confirm button is available in modal');
                // Ensure onclick is set
                if (!confirmButton.onclick) {
                    confirmButton.onclick = handleColorSizeConfirm;
                    console.log('âœ… Set onclick handler for confirm button');
                }
            } else {
                console.error('âŒ Confirm button not found in modal');
            }
        }, 300);
        
    } catch (error) {
        console.error('âŒ Error showing modal:', error);
        alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ù…ÙˆØ¯Ø§Ù„ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ù…Ù‚Ø§Ø³');
    }
}

// Add event listener for confirm button
document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸ”§ Setting up color/size selection modal...');
    
    // Wait a bit for modal to be loaded
    setTimeout(() => {
        setupColorSizeModal();
    }, 100);
});

// Setup color/size modal event listeners
function setupColorSizeModal() {
    const confirmButton = document.getElementById('confirmColorSize');
    const modalElement = document.getElementById('colorSizeSelectionModal');
    
    if (!modalElement) {
        console.error('âŒ Color/Size selection modal not found during setup!');
        return;
    }
    
    if (!confirmButton) {
        console.error('âŒ Confirm button not found in modal!');
        return;
    }
    
    console.log('âœ… Modal and confirm button found, setting up event listener...');
    
    // Remove any existing event listeners
    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    
    // Add new event listener
    newConfirmButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('ğŸ¯ Confirm button clicked');
        
        const selectedColor = document.getElementById('selectedColor')?.value || '';
        const selectedSize = document.getElementById('selectedSize')?.value || '';

        console.log('ğŸ¨ Selected color:', selectedColor);
        console.log('ğŸ“ Selected size:', selectedSize);

        if (!selectedColor || !selectedSize) {
            alert('âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ù…Ù‚Ø§Ø³');
            return;
        }

        if (selectedProductInfo) {
            console.log('ğŸ“¦ Adding product with color/size:', selectedProductInfo);
            
            // Add to cart with color and size info
            addProductToCartWithColorSize(
                selectedProductInfo.productId,
                selectedProductInfo.productName,
                selectedProductInfo.productPrice,
                selectedColor,
                selectedSize
            );

            // Close modal
            try {
                const modal = bootstrap.Modal.getInstance(modalElement);
                if (modal) {
                    modal.hide();
                    console.log('âœ… Modal closed successfully');
                } else {
                    console.warn('âš ï¸ Could not get modal instance, using cleanup function');
                    cleanupModal();
                }
            } catch (error) {
                console.error('âŒ Error closing modal:', error);
                cleanupModal();
            }

            selectedProductInfo = null;
        } else {
            console.error('âŒ No selected product info available!');
            alert('âŒ Ø®Ø·Ø£: Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªØ§Ø­Ø©');
        }
    });
    
    console.log('âœ… Color/size selection modal setup completed');
    
    // Add event listener for cancel button
    const cancelButton = modalElement.querySelector('.btn-secondary');
    if (cancelButton) {
        const newCancelButton = cancelButton.cloneNode(true);
        cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
        
        newCancelButton.addEventListener('click', function() {
            console.log('âŒ Cancel button clicked');
            selectedProductInfo = null;
            cleanupModal();
        });
    }
    
    // Add event listener for modal close (X button)
    const closeButton = modalElement.querySelector('.btn-close');
    if (closeButton) {
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        
        newCloseButton.addEventListener('click', function() {
            console.log('âŒ Close button clicked');
            selectedProductInfo = null;
            cleanupModal();
        });
    }
    
    // Add event listener for backdrop click
    modalElement.addEventListener('click', function(event) {
        if (event.target === modalElement) {
            console.log('âŒ Backdrop clicked');
            selectedProductInfo = null;
            cleanupModal();
        }
    });
}

// Handle color/size confirmation
function handleColorSizeConfirm() {
    console.log('ğŸ¯ handleColorSizeConfirm called');
    
    const selectedColor = document.getElementById('selectedColor')?.value || '';
    const selectedSize = document.getElementById('selectedSize')?.value || '';
    const modalElement = document.getElementById('colorSizeSelectionModal');

    console.log('ğŸ¨ Selected color:', selectedColor);
    console.log('ğŸ“ Selected size:', selectedSize);

    if (!selectedColor || !selectedSize) {
        alert('âš ï¸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ù…Ù‚Ø§Ø³');
        return;
    }

    if (selectedProductInfo) {
        console.log('ğŸ“¦ Adding product with color/size:', selectedProductInfo);
        
        // Add to cart with color and size info
        addProductToCartWithColorSize(
            selectedProductInfo.productId,
            selectedProductInfo.productName,
            selectedProductInfo.productPrice,
            selectedColor,
            selectedSize
        );

        // Close modal
        try {
            const modal = bootstrap.Modal.getInstance(modalElement);
            if (modal) {
                modal.hide();
                console.log('âœ… Modal closed successfully');
            } else {
                console.warn('âš ï¸ Could not get modal instance, using cleanup function');
                cleanupModal();
            }
        } catch (error) {
            console.error('âŒ Error closing modal:', error);
            cleanupModal();
        }

        selectedProductInfo = null;
    } else {
        console.error('âŒ No selected product info available!');
        alert('âŒ Ø®Ø·Ø£: Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ØªØ§Ø­Ø©');
    }
}

// Helper function to clean up modal
function cleanupModal() {
    const modalElement = document.getElementById('colorSizeSelectionModal');
    if (modalElement) {
        // Remove modal-open class from body
        document.body.classList.remove('modal-open');
        document.body.style.overflow = '';
        
        // Remove backdrop
        const backdrop = document.querySelector('.modal-backdrop');
        if (backdrop) {
            backdrop.remove();
        }
        
        // Reset modal state
        modalElement.classList.remove('show');
        modalElement.style.display = 'none';
        modalElement.setAttribute('aria-hidden', 'true');
    }
}

function addProductToCartWithColorSize(productId, productName, productPrice, color, size) {
    console.log(`ğŸ”„ Adding product to cart with color/size: ${productName} (${color}, ${size})`);
    
    // Enhanced input validation
    if (!productId || !productName || productPrice === null || productPrice === undefined) {
        console.error('âŒ Invalid parameters for addProductToCartWithColorSize:', { productId, productName, productPrice, color, size });
        showMessage('âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'error');
        return;
    }
    
    // Enhanced duplicate prevention at cart level
    const now = Date.now();
    const cartKey = `${productId}_${productName}_${color || ''}_${size || ''}`;
    
    // Initialize cart tracker
    if (!window.cartAddTracker) {
        window.cartAddTracker = {};
    }
    
    // Prevent adding the same product within 5 seconds (increased for better reliability)
    if (window.cartAddTracker[cartKey] && (now - window.cartAddTracker[cartKey]) < 5000) {
        console.log(`âš ï¸ Cart: Preventing duplicate add of ${productName} (last added ${now - window.cartAddTracker[cartKey]}ms ago)`);
        showMessage(`ØªÙ… Ù…Ù†Ø¹ Ø¥Ø¶Ø§ÙØ© ${productName} Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ (Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±)`, 'warning');
        return;
    }
    
    // Also check for any product with same ID being added within 2 seconds (global prevention)
    const globalKey = `product_${productId}`;
    if (window.cartAddTracker[globalKey] && (now - window.cartAddTracker[globalKey]) < 2000) {
        console.log(`âš ï¸ Cart: Preventing duplicate add of product ID ${productId} (last added ${now - window.cartAddTracker[globalKey]}ms ago)`);
        showMessage(`ØªÙ… Ù…Ù†Ø¹ Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ (Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±)`, 'warning');
        return;
    }
    
    // Update both trackers
    window.cartAddTracker[cartKey] = now;
    window.cartAddTracker[globalKey] = now;
    
    try {
        console.log(`ğŸ”„ Adding product to cart: ID=${productId}, Name="${productName}", Price=${productPrice}, Color=${color}, Size=${size}`);
        console.log(`ğŸ”„ Return mode: ${isReturnMode}`);
        
        // Determine quantity based on current mode
        const baseQuantity = 1;
        const quantity = isReturnMode ? -baseQuantity : baseQuantity;
        const total = quantity * productPrice;
        
        console.log(`ğŸ“Š Calculated: Quantity=${quantity}, Total=${total}`);
        
        // Validate productId
        if (!productId || productId === 0) {
            console.error('âŒ Invalid productId:', productId);
            alert('âŒ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± ØµØ­ÙŠØ­');
            return;
        }
        
        // Create cart item with color and size
        const cartItem = {
            id: Date.now(),
            productId: parseInt(productId),
            name: productName,
            price: parseFloat(productPrice),
            quantity: quantity,
            total: total,
            discount: 0,
            color: color,
            size: size
        };
        
        // Ensure total is correctly calculated
        cartItem.total = quantity * productPrice;
        
        console.log('ğŸ“¦ Created cart item with color/size:', cartItem);
        
        // Check for duplicate returns prevention
        if (isReturnMode) {
            const existingReturnItem = cart.find(item => 
                (item.productId == cartItem.productId || item.name === cartItem.name) && 
                item.quantity < 0 && 
                item.color === color && 
                item.size === size
            );
            
            if (existingReturnItem) {
                console.log(`âš ï¸ Product with same color/size already in cart for return, updating quantity instead of adding new item`);
                existingReturnItem.quantity -= 1;
                
                // Recalculate total with discount
                const itemSubTotal = Math.abs(existingReturnItem.price * existingReturnItem.quantity);
                const discountAmount = existingReturnItem.discount || 0;
                existingReturnItem.total = Math.round(-(itemSubTotal - discountAmount) * 100) / 100;
                
                console.log(`ğŸ“Š Updated existing return item:`, existingReturnItem);
            } else {
                // Add to cart
                cart.push(cartItem);
            }
        } else {
            // Add to cart normally for sales
            cart.push(cartItem);
        }
        
        window.cart = cart;
        
        // Update display
        updateCartDisplay();
        updateCartSummary();
        
        // Update process button state safely
        if (typeof updateProcessButtonState === 'function') {
            updateProcessButtonState();
        } else {
            console.warn('âš ï¸ updateProcessButtonState function not available');
        }
        
        const modeText = isReturnMode ? 'Ù„Ù„Ø¥Ø±Ø¬Ø§Ø¹' : 'Ù„Ù„Ø¨ÙŠØ¹';
        console.log(`âœ… Added ${modeText}: ${productName} (Qty: ${quantity}, Color: ${color}, Size: ${size})`);
        console.log('ğŸ›’ Cart after addition:', cart);
        console.log('ğŸ›’ Total items in cart:', cart.length);
        
    } catch (error) {
        console.error('âŒ Error adding product to cart:', error);
        alert('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬ Ù„Ù„Ø³Ù„Ø©');
    }
}

// Make functions available globally
window.showColorSizeSelectionForCart = showColorSizeSelectionForCart;
window.addProductToCartWithModal = addProductToCartWithModal;